# moai-lang-nextjs-advanced

Master Next.js 16 App Router, Server Components, streaming, and middleware for modern web applications.

## Quick Start

Next.js is a production-ready React framework with built-in optimization for performance, SEO, and developer experience. Use this skill when building modern web applications, implementing server-side rendering, creating dynamic routes, or optimizing performance.

## Core Patterns

### Pattern 1: App Router with Server Components

**Pattern**: Use server components by default for data fetching, with selective client components for interactivity.

```typescript
// app/layout.tsx - Root layout (Server Component by default)
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'My App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

// app/dashboard/page.tsx - Page component (Server Component)
import { Suspense } from 'react';
import { getUserData } from '@/lib/db';
import { UserCard } from '@/components/UserCard';
import { Skeleton } from '@/components/Skeleton';

export const revalidate = 60; // ISR: Revalidate every 60 seconds

async function UserDataSection({ userId }: { userId: string }) {
  const userData = await getUserData(userId);

  return (
    <div className="space-y-4">
      <UserCard user={userData} />
    </div>
  );
}

export default function DashboardPage() {
  return (
    <main>
      <h1>Dashboard</h1>

      <Suspense fallback={<Skeleton />}>
        <UserDataSection userId="123" />
      </Suspense>
    </main>
  );
}

// app/dashboard/ClientComponent.tsx - Client Component (uses 'use client')
'use client';

import { useState } from 'react';

export function InteractiveCounter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**When to use**:
- Building new Next.js applications
- Fetching data on the server (no API roundtrips)
- Rendering static pages with ISR
- Mixing server and client components strategically

**Key benefits**:
- Reduced JavaScript sent to browser
- Direct database access from pages
- Automatic code splitting
- Built-in search engine optimization

### Pattern 2: Dynamic Routes & Segment Configuration

**Pattern**: Create dynamic routes with flexible segment configuration.

```typescript
// app/posts/[id]/page.tsx - Dynamic segment
import { notFound } from 'next/navigation';
import { getPost } from '@/lib/db';
import { format } from 'date-fns';

// Generate static params for known posts
export async function generateStaticParams() {
  const posts = await getPosts();
  return posts.map((post) => ({
    id: post.id.toString(),
  }));
}

// Custom metadata for each post
export async function generateMetadata({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const post = await getPost(id);

  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      url: `https://example.com/posts/${id}`,
      images: [post.imageUrl],
    },
  };
}

async function Post({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const post = await getPost(id);

  if (!post) {
    notFound();
  }

  return (
    <article className="prose max-w-2xl mx-auto">
      <h1>{post.title}</h1>
      <time>{format(new Date(post.publishedAt), 'MMMM d, yyyy')}</time>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}

export default Post;

// app/posts/layout.tsx - Nested layout for posts section
export default function PostsLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="container mx-auto">
      <nav>
        <a href="/posts">All Posts</a>
      </nav>
      {children}
    </div>
  );
}
```

**When to use**:
- Creating blog post pages with URLs like `/posts/[id]`
- Generating static content ahead of time
- Creating catch-all routes like `/docs/[...slug]`
- Organizing related pages with nested layouts

**Key benefits**:
- SEO-friendly dynamic URLs
- Automatic static generation
- Parameterized layouts and metadata
- File-based routing structure

### Pattern 3: Middleware & Request Interception

**Pattern**: Intercept and transform requests before they reach your routes.

```typescript
// middleware.ts - Top-level middleware
import { NextRequest, NextResponse } from 'next/server';

export function middleware(request: NextRequest) {
  // Add request ID for tracing
  const requestId = crypto.randomUUID();
  const response = NextResponse.next();

  response.headers.set('x-request-id', requestId);

  // Redirect unauthenticated users
  const token = request.cookies.get('auth-token');

  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // Add custom headers
  response.headers.set(
    'x-custom-header',
    'Value from middleware'
  );

  // Clone and modify headers for internal use
  const clonedRequest = request.clone();
  clonedRequest.headers.set('x-user-id', '123');

  return response;
}

// Configure which routes use middleware
export const config = {
  matcher: [
    // Match all paths except static assets
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};

// app/api/auth/[...auth]/route.ts - Catch-all API route
import { NextRequest, NextResponse } from 'next/server';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ auth: string[] }> }
) {
  const { auth } = await params;
  const [action, ...rest] = auth;

  switch (action) {
    case 'login':
      return NextResponse.json({ action: 'login', data: rest });
    case 'logout':
      return NextResponse.json({ action: 'logout' });
    default:
      return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }
}
```

**When to use**:
- Enforcing authentication on protected routes
- Adding request tracing and logging
- Redirecting based on user properties
- Customizing responses with headers

**Key benefits**:
- Centralized request handling
- No performance overhead
- Edge runtime support (ultra-fast)
- Authentication at request boundary

## Progressive Disclosure

### Level 1: Basic Setup
- Create Next.js project with App Router
- Build pages with file-based routing
- Use Link component for navigation
- Implement basic layouts

### Level 2: Advanced Patterns
- Server components for data fetching
- Dynamic routes with [id] segments
- Incremental static regeneration (ISR)
- Image optimization with next/image

### Level 3: Expert Optimization
- Edge middleware for request handling
- Streaming responses to reduce Time to First Byte
- Complex nested layouts and route groups
- Revalidation strategies and cache management

## Works Well With

- **React 19**: use() hook, Server Components, Suspense
- **TypeScript**: Full type safety with strict mode
- **Tailwind CSS**: Utility-first styling
- **shadcn/ui**: Pre-built accessible components
- **Supabase**: Database queries in server components
- **Vercel**: Official hosting platform with zero-config deploys

## References

- **Official Documentation**: https://nextjs.org/docs
- **App Router Guide**: https://nextjs.org/docs/app
- **Server Components**: https://nextjs.org/docs/app/building-your-application/rendering/server-components
- **Dynamic Routes**: https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes
- **Middleware**: https://nextjs.org/docs/app/building-your-application/routing/middleware
