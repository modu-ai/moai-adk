---
name: moai-domain-readme-generation
description: Generate professional GitHub README.md documentation by analyzing project structure, metadata (package.json, pyproject.toml, go.mod), and existing content. Creates or updates README sections including project overview, installation, usage examples, features, tech stack, and license. Use when creating documentation for GitHub repositories, bootstrapping open-source projects, or updating README files with latest project information.
allowed-tools:
  - Read
  - Write
  - Glob
  - Bash
---

# README Generator Expert

## Skill Metadata
| Field | Value |
| ----- | ----- |
| Version | 2.0.0 |
| Created | 2025-10-23 |
| Updated | 2025-10-23 |
| Allowed tools | Read, Write, Glob, Bash |
| Auto-load | On demand for README generation/update requests |
| Trigger cues | README, documentation, GitHub repository, project description, installation guide, open-source documentation, README.md generation |
| Tier | 4 |

## What it does

Automatically generates professional GitHub README.md documentation by:
- Analyzing project metadata files (package.json, pyproject.toml, go.mod, Cargo.toml, etc.)
- Detecting project structure and technology stack
- Extracting existing README content (if present)
- Creating well-structured sections following GitHub best practices
- Supporting multiple languages and frameworks
- Generating badges, installation instructions, usage examples, and contribution guidelines

## When to use

- Creating a new GitHub repository and need a professional README
- Updating outdated README documentation
- Standardizing README format across multiple projects
- Generating documentation for open-source projects
- Bootstrapping project documentation from scratch
- MoAI-ADK project initialization (`/alfred:0-project`)
- After major feature releases (`/alfred:3-sync`)

## How it works

### README Structure Strategy

**GitHub Best Practices** (based on GitHub Docs 2025):
- **Essential Sections**: What, Why, How to get started, Help, Maintainers
- **Table of Contents**: Auto-generated by GitHub from headings
- **Relative Links**: Use relative paths for better portability
- **Character Limit**: Keep under 500 KiB
- **Complementary Files**: Link to LICENSE, CONTRIBUTING.md, CODE_OF_CONDUCT.md

**MoAI-ADK README Structure** (reference):
```markdown
# Project Title
[Language badges]

> One-line value proposition

## 1. Project at a Glance
[Navigation table]

## What is [Project]?
### The Problem
### The Solution
### Core Promises

## Why Do You Need It?
[Comparison table: Challenge vs Solution]

## Quick Start (5 minutes)
### Installation
### Setup
### First Feature

## Core Workflow
[Mermaid diagram or step-by-step]

## Key Concepts
[5-7 foundational ideas]

## FAQ

## Additional Resources

## Community & Support
```

### Project Metadata Detection

**Python Projects**:
```bash
# pyproject.toml (PEP 621)
Read pyproject.toml ‚Üí Extract:
- project.name
- project.version
- project.description
- project.dependencies
- project.requires-python
- project.license
- project.urls (homepage, repository)

# setup.py (legacy)
Read setup.py ‚Üí Extract:
- name, version, description
- install_requires
- python_requires
```

**JavaScript/TypeScript Projects**:
```bash
# package.json
Read package.json ‚Üí Extract:
- name, version, description
- scripts (start, build, test)
- dependencies, devDependencies
- engines.node
- license, repository
```

**Go Projects**:
```bash
# go.mod
Read go.mod ‚Üí Extract:
- module name
- go version
- dependencies

# Look for main.go
Glob **/main.go ‚Üí Identify CLI tool vs library
```

**Rust Projects**:
```bash
# Cargo.toml
Read Cargo.toml ‚Üí Extract:
- package.name, version, description
- dependencies
- license
```

**Multi-language Detection**:
```bash
# Priority order (first match wins)
1. pyproject.toml ‚Üí Python
2. package.json ‚Üí JavaScript/TypeScript
3. go.mod ‚Üí Go
4. Cargo.toml ‚Üí Rust
5. pom.xml ‚Üí Java (Maven)
6. build.gradle ‚Üí Java/Kotlin (Gradle)
7. pubspec.yaml ‚Üí Dart/Flutter
```

### README Section Generation

**1. Header Section (High Freedom)**

**Principles**:
- Clear project name and tagline
- Visual badges for key metrics (CI/CD, coverage, version)
- Multi-language support indicators
- One-line value proposition

**Template**:
```markdown
# [Project Name]

[Multi-language links if available]

[![Badge 1]](link1) [![Badge 2]](link2) [![Badge 3]](link3)

> **[One-line value proposition capturing core benefit]**
```

**Badge Recommendations**:
- PyPI/npm/crates.io version badge
- License badge (MIT, Apache, GPL)
- Language badge (Python 3.x+, Node.js, Go)
- CI/CD status badge (GitHub Actions, GitLab CI)
- Test coverage badge (Codecov, Coveralls)

**2. Project Overview (High Freedom)**

**Principles**:
- Problem statement first (why this exists)
- Solution explanation
- Core promises (3-5 key benefits)
- Target audience

**Pattern**:
```markdown
## What is [Project]?

### The Problem: [Context]
[Describe the pain points users face without this tool]

### The Solution: [Approach]
[Explain how your project solves these problems]

### Core Promises
1. **Promise 1**: [Specific benefit]
2. **Promise 2**: [Specific benefit]
3. **Promise 3**: [Specific benefit]
```

**3. Installation Guide (Low Freedom)**

**Language-Specific Scripts**:

**Python**:
```bash
# Installation commands (exact syntax)
# pip (standard)
pip install [package-name]

# uv (recommended if applicable)
uv tool install [package-name]

# Verify installation
[package-name] --version
```

**JavaScript/TypeScript**:
```bash
# npm
npm install [package-name]

# pnpm
pnpm add [package-name]

# yarn
yarn add [package-name]

# Verify
node -e "require('[package-name]')"
```

**Go**:
```bash
# go install
go install [module-path]@latest

# Verify
[binary-name] --version
```

**Rust**:
```bash
# cargo
cargo install [package-name]

# Verify
[binary-name] --version
```

**4. Quick Start (Medium Freedom)**

**Pattern**:
```markdown
## Quick Start (5 minutes)

### Step 1: Install ([time estimate])
[Installation commands from section 3]

### Step 2: Initialize ([time estimate])
[Setup commands]

### Step 3: First Feature ([time estimate])
[Minimal working example]
```

**Examples**:
- CLI tools: Show `--help` output and basic command
- Libraries: Show minimal import and usage
- Frameworks: Show project scaffold and hello-world
- APIs: Show authentication and first request

**5. Features Section (High Freedom)**

**Principles**:
- Focus on user-facing capabilities
- Use checkmarks for completed features
- Group related features
- Highlight unique differentiators

**Pattern**:
```markdown
## Features

### Core Capabilities
- ‚úÖ Feature 1 (brief description)
- ‚úÖ Feature 2 (brief description)
- ‚úÖ Feature 3 (brief description)

### Advanced Features
- ‚úÖ Advanced feature 1
- üöß In progress feature 2
- üìã Planned feature 3
```

**6. Technology Stack (Medium Freedom)**

**Pattern**:
```markdown
## Technology Stack

| Category | Technology | Version | Purpose |
| --- | --- | --- | --- |
| Language | Python | 3.12+ | Core implementation |
| Framework | FastAPI | 0.x | API server |
| Database | PostgreSQL | 16.x | Data persistence |
| Testing | pytest | 8.x | Unit & integration tests |
| Deployment | Docker | 27.0+ | Containerization |
```

**Detection Strategy**:
- Parse dependencies from metadata files
- Group by category (language, framework, database, testing, deployment)
- Include version constraints
- Add brief purpose explanation

**7. Usage Examples (Medium Freedom)**

**Pattern**:
```markdown
## Usage Examples

### Basic Usage
[Code example with comments]

### Advanced Usage
[More complex example]

### Integration Example
[How to use with other tools]
```

**Code Block Guidelines**:
- Include language identifier for syntax highlighting
- Add inline comments for clarity
- Show expected output
- Keep examples under 20 lines

**8. Documentation & Resources (Low Freedom)**

**Pattern**:
```markdown
## Documentation

| Resource | Link |
| --- | --- |
| Full Documentation | [link] |
| API Reference | [link] |
| Changelog | [CHANGELOG.md](CHANGELOG.md) |
| Contributing Guide | [CONTRIBUTING.md](CONTRIBUTING.md) |
| License | [LICENSE](LICENSE) |
```

**9. Community & Support (Low Freedom)**

**Pattern**:
```markdown
## Community & Support

| Channel | Link |
| --- | --- |
| GitHub Repository | [link] |
| Issue Tracker | [link] |
| Discussions | [link] |
| Package Registry | [PyPI/npm/crates.io link] |
```

### README Generation Workflow

**Phase 1: Analysis (Medium Freedom)**

```pseudocode
1. Detect project root (look for .git directory)
2. Scan for metadata files (priority order)
3. Parse metadata and extract:
   - name, version, description
   - dependencies and tech stack
   - license, repository URLs
4. Check for existing README.md
5. If exists:
   - Parse existing sections
   - Identify gaps or outdated content
   - Plan update strategy (merge vs replace)
6. Detect project type:
   - CLI tool (has binary/scripts)
   - Library (no executables)
   - Framework (has templates/scaffolding)
   - Application (has main entry point)
```

**Phase 2: Section Generation (Mixed Freedom)**

```pseudocode
1. Generate Header (High Freedom)
   - Create title from project name
   - Generate badges from metadata
   - Craft value proposition from description

2. Generate Installation (Low Freedom)
   - Use language-specific templates
   - Include verification commands
   - Add troubleshooting notes if needed

3. Generate Quick Start (Medium Freedom)
   - Create 3-step onboarding flow
   - Include time estimates per step
   - Add first meaningful example

4. Generate Features (High Freedom)
   - List capabilities from description
   - Organize by priority or category
   - Use visual indicators (‚úÖ, üöß, üìã)

5. Generate Tech Stack (Medium Freedom)
   - Parse dependencies into table
   - Group by category
   - Add version constraints

6. Generate Examples (Medium Freedom)
   - Create basic usage example
   - Add 1-2 advanced examples
   - Include expected outputs

7. Generate Footer (Low Freedom)
   - Add documentation links
   - Add community/support section
   - Include license and copyright
```

**Phase 3: Validation & Output (Low Freedom)**

```bash
#!/bin/bash
set -euo pipefail

README_FILE="$1"

# Validation checks
echo "üîç Validating README.md structure..."

# Check file size (< 500 KiB per GitHub limit)
FILE_SIZE=$(wc -c < "$README_FILE")
if [ "$FILE_SIZE" -gt 512000 ]; then
  echo "‚ö†Ô∏è  WARNING: README exceeds 500 KiB GitHub limit" >&2
fi

# Check for required sections
REQUIRED_SECTIONS=(
  "# "           # Title (H1)
  "## "          # At least one H2 section
  "Installation" # Installation instructions
)

for SECTION in "${REQUIRED_SECTIONS[@]}"; do
  if ! grep -q "$SECTION" "$README_FILE"; then
    echo "‚ùå ERROR: Missing required section: $SECTION" >&2
    exit 1
  fi
done

# Check for relative links (no absolute paths)
if grep -q "](http://localhost" "$README_FILE"; then
  echo "‚ö†Ô∏è  WARNING: Found localhost links (use relative paths)" >&2
fi

# Validate markdown syntax
if command -v markdownlint &> /dev/null; then
  markdownlint "$README_FILE" || echo "‚ö†Ô∏è  Markdown linting warnings"
fi

echo "‚úÖ README validation complete"
```

### Update vs Create Strategy

**When to CREATE (new README)**:
- No existing README.md file
- Existing README is < 100 characters (stub)
- User explicitly requests "create from scratch"

**When to UPDATE (merge existing)**:
- Existing README has substantial content (> 100 chars)
- Preserve user-customized sections
- Update outdated sections (version, dependencies, badges)
- Add missing sections without removing existing ones

**Merge Algorithm (Medium Freedom)**:
```pseudocode
1. Parse existing README into sections
2. Identify section types:
   - Standard (Installation, Usage, Features)
   - Custom (user-added content)
3. For each standard section:
   - If exists in old README:
     - Compare with generated version
     - If outdated (version mismatch, missing info):
       - Replace with new version
       - Preserve user-added notes (look for custom subsections)
   - If missing:
     - Insert in appropriate position
4. Preserve all custom sections
5. Reorder sections to match best-practice structure
6. Output merged README
```

## Examples

See `examples.md` for complete README generation scenarios:
- Python CLI tool (MoAI-ADK style)
- TypeScript library (npm package)
- Go microservice (Docker deployment)
- Rust CLI tool (cargo install)

## Inputs
- Project root directory path
- Metadata files (pyproject.toml, package.json, etc.)
- Existing README.md (if present)
- Optional: User preferences (style, sections to include/exclude)

## Outputs
- Complete README.md file (markdown format)
- Validation report (missing sections, warnings)
- Update summary (if merging with existing README)

## Failure Modes
- **No metadata files found**: Request user to provide project name, version, description manually
- **Multiple metadata files conflict**: Ask user to clarify primary language/framework
- **Existing README is complex**: Suggest "update" mode instead of "create"
- **Required sections cannot be generated**: Provide template placeholders with TODO comments

## Dependencies
- Project metadata files (pyproject.toml, package.json, go.mod, Cargo.toml)
- `.git` directory (for repository detection)
- Optional: LICENSE file (for license badge)
- Optional: CHANGELOG.md, CONTRIBUTING.md (for links)

## References
- GitHub. "About READMEs." https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-readmes (accessed 2025-10-23).
- MoAI-ADK. "README.md structure reference." https://github.com/modu-ai/moai-adk/blob/main/README.md (accessed 2025-10-23).
- Shields.io. "Badge generation service." https://shields.io/ (accessed 2025-10-23).
- CommonMark. "Markdown specification." https://commonmark.org/ (accessed 2025-10-23).

## Changelog
- 2025-10-23: v2.0.0 - Initial release with multi-language support, GitHub best practices, and MoAI-ADK structure reference.

## Works well with

- moai-alfred-language-detection (auto-detect project stack)
- moai-domain-cli-tool (CLI tool documentation patterns)
- moai-domain-backend (backend service documentation)
- moai-foundation-git (Git repository analysis)
- moai-lang-python (Python-specific README sections)
- moai-lang-typescript (TypeScript-specific README sections)

## Best Practices
- **Start with metadata analysis**: Never assume project details without reading metadata files
- **Respect existing content**: When updating, preserve user-customized sections
- **Use relative links**: Ensure README works in cloned repositories
- **Keep it concise**: Under 500 KiB per GitHub limit
- **Multi-language support**: Add language badges if translations exist
- **Visual elements**: Use badges, tables, and code blocks for clarity
- **Validation**: Always validate markdown syntax and required sections
- **Progressive disclosure**: Core info first, detailed docs linked separately
- **Update regularly**: README should reflect current project state (version, features, dependencies)
