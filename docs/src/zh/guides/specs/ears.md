---
title: EARS 语法详细指南
description: 掌握 MoAI-ADK 中使用的 EARS（Easy Approach to Requirements Syntax）语法，编写清晰、结构化的需求文档
---

# EARS 语法详细指南

EARS（Easy Approach to Requirements Syntax）是一种结构化的需求描述语法，它提供了 5 种清晰的模式来描述不同类型的需求。在 MoAI-ADK 中，EARS 语法是 SPEC 文档的核心组成部分，确保需求描述的一致性和可测试性。

## EARS 语法概述

### 什么是 EARS？

EARS 是由 The University of Manchester 开发的需求工程方法，旨在解决自然语言需求描述中的歧义性问题。它提供了一套标准化的语法模式，使需求描述更加清晰、一致和可测试。

### EARS 的优势

#### 1. 消除歧义
- **标准化语法**：固定的句式结构减少理解偏差
- **明确词汇**：使用精确的动词和限定词
- **逻辑清晰**：因果关系和条件关系明确

#### 2. 提高可测试性
- **具体可验证**：每个需求都可以转化为测试用例
- **边界明确**：清楚定义功能的边界和约束
- **条件完整**：包含所有必要的触发条件

#### 3. 便于自动化处理
- **模式识别**：机器可以自动识别和分类需求
- **一致性检查**：自动验证语法正确性
- **关联分析**：自动发现需求间的关系

#### 4. 改善团队协作
- **统一语言**：团队成员使用相同的表达方式
- **减少误解**：标准化的格式减少沟通成本
- **知识传承**：新成员更容易理解现有需求

---

## EARS 的五种模式

### 1. Ubiquitous Requirements（普遍需求）

#### 语法结构
```
系统必须 [动词] [对象]
```

#### 模式特征
- **永恒性**：描述系统必须持续具备的功能
- **无条件**：不需要特定触发条件
- **核心功能**：描述系统的基本能力

#### 详细语法规则
```yaml
基本结构:
  主语: "系统"
  情态动词: "必须"
  主要动词: [动作动词]
  宾语: [功能对象]

可选修饰:
  副词: 永远、始终、持续
  条件: 在所有情况下
  范围: 全部、每个
```

#### 实用示例

**系统核心功能**：
```yaml
## Ubiquitous Requirements
- 系统必须提供用户注册功能
- 系统必须支持多语言界面
- 系统必须记录所有操作日志
- 系统必须支持数据备份和恢复
- 系统必须保护用户隐私数据
- 系统必须维护数据一致性
```

**非功能性要求**：
```yaml
## Ubiquitous Requirements
- 系统必须遵守 GDPR 数据保护法规
- 系统必须实现端到端加密
- 系统必须支持 99.9% 的可用性
- 系统必须定期进行安全审计
- 系统必须提供完整的审计日志
```

**架构要求**：
```yaml
## Ubiquitous Requirements
- 系统必须采用微服务架构
- 系统必须实现水平扩展
- 系统必须支持容器化部署
- 系统必须提供 API 版本管理
- 系统必须实现服务发现机制
```

#### 使用场景

| 场景类型 | 示例 | 说明 |
|----------|------|------|
| 核心业务功能 | 系统必须支持订单创建 | 描述系统必须具备的基本功能 |
| 系统架构 | 系统必须使用 RESTful API | 定义技术架构要求 |
| 非功能性要求 | 系统必须响应时间 < 2秒 | 性能和质量标准 |
| 合规要求 | 系统必须符合 PCI DSS 标准 | 法规和合规要求 |

#### 编写技巧

**✅ 好的实践**：
```yaml
# 具体明确
- 系统必须支持 JPEG、PNG、GIF 格式的图片上传

# 包含质量标准
- 系统必须在 2 秒内完成用户认证

# 使用专业术语
- 系统必须实现 OAuth 2.0 认证协议

# 考虑边界条件
- 系统必须支持最大 100MB 的文件上传
```

**<span class="material-icons">cancel</span> 避免的做法**：
```yaml
# 过于模糊
- 系统应该支持图片

# 缺少质量标准
- 系统要快速响应

# 使用不确定词汇
- 系统可能需要支持多语言

# 忽略边界条件
- 系统要支持文件上传
```

---

### 2. Event-driven Requirements（事件驱动需求）

#### 语法结构
```
当 [条件] 时，系统必须 [响应]
```

#### 模式特征
- **条件性**：基于特定事件或条件
- **响应性**：描述系统在特定情况下的行为
- **因果关系**：明确的触发-响应关系

#### 详细语法规则
```yaml
触发条件:
  时间状语: "当 [事件] 时"
  事件源: 用户操作、系统事件、外部触发、定时事件

响应动作:
  主语: "系统"
  情态动词: "必须"、"应该"
  动作: 具体的响应行为
  对象: 响应作用的对象

时间关系:
  立即响应: "必须立即"、"应该立即"
  延迟响应: "必须在 [时间] 内"、"应该在 [时间] 内"
  异步响应: "必须"、"应该"（默认异步）
```

#### 实用示例

**用户交互场景**：
```yaml
## Event-driven Requirements
- 当用户提供有效邮箱和密码时，系统必须发送验证邮件
- 当用户点击验证链接时，系统必须激活用户账户
- 当用户提交注册表单时，系统必须验证所有必填字段
- 当用户登录失败超过 3 次时，系统必须锁定账户 15 分钟
- 当用户修改密码时，系统必须要求输入当前密码
- 当用户注销时，系统必须清除所有会话数据
```

**系统集成场景**：
```yaml
## Event-driven Requirements
- 当收到支付网关回调时，系统必须更新订单状态
- 当库存系统通知缺货时，系统必须标记商品为不可用
- 当第三方 API 返回错误时，系统必须记录错误并重试
- 当系统检测到异常访问时，系统必须发送安全警报
- 当数据库连接失败时，系统必须切换到备用数据库
```

**数据处理场景**：
```yaml
## Event-driven Requirements
- 当用户上传文件时，系统必须进行病毒扫描
- 当数据同步完成时，系统必须更新同步状态
- 当缓存过期时，系统必须重新加载数据
- 当数据迁移完成时，系统必须验证数据完整性
- 当系统负载超过阈值时，系统必须启用负载均衡
```

#### 复杂条件处理

**多重条件**：
```yaml
## Event-driven Requirements
- 当用户是 VIP 且购物金额超过 1000 元时，系统必须免运费
- 当商品库存低于 10 且用户已收藏时，系统必须发送补货通知
- 当用户使用移动设备且网络不稳定时，系统必须启用离线模式
```

**时间条件**：
```yaml
## Event-driven Requirements
- 当系统时间到达午夜时，系统必须执行日常备份
- 当用户会话超过 30 分钟无活动时，系统必须自动登出
- 当促销活动结束时，系统必须自动更新商品价格
```

#### 使用场景

| 触发类型 | 示例 | 应用场景 |
|----------|------|----------|
| 用户操作 | 当用户点击按钮时 | UI 交互响应 |
| 系统事件 | 当系统启动时 | 系统初始化 |
| 外部事件 | 当收到第三方通知时 | 系统集成 |
| 定时事件 | 当每天零点时 | 定时任务 |
| 状态变化 | 当订单状态改变时 | 业务流程 |

#### 编写技巧

**✅ 好的实践**：
```yaml
# 明确的触发条件
- 当用户输入错误的登录凭证时，系统必须显示错误信息

# 具体的响应行为
- 当用户上传文件时，系统必须显示上传进度并保存到指定目录

# 包含时间要求
- 当用户点击保存时，系统必须在 3 秒内完成保存操作

# 考虑边界情况
- 当用户连续输入错误密码 5 次时，系统必须永久锁定账户
```

**<span class="material-icons">cancel</span> 避免的做法**：
```yaml
# 触发条件模糊
- 当有问题时，系统要处理

# 响应行为不明确
- 当用户操作时，系统要响应

# 缺少时间要求
- 当数据量大时，系统要优化

# 忽略异常情况
- 当网络正常时，系统要工作
```

---

### 3. State-driven Requirements（状态驱动需求）

#### 语法结构
```
当 [状态条件] 时，系统必须 [行为]
```

#### 模式特征
- **状态性**：基于系统当前状态的行为
- **持续性**：状态持续期间的行为保持
- **条件性**：特定状态下的功能限制

#### 详细语法规则
```yaml
状态条件:
  时间状语: "当 [状态] 时"
  状态类型:
    - 用户状态：未认证、已认证、VIP、锁定等
    - 业务状态：待处理、进行中、已完成、已取消等
    - 系统状态：维护模式、降级模式、离线模式等
    - 数据状态：草稿、已发布、已归档等

行为约束:
  允许行为: 系统在此状态下可以执行的操作
  禁止行为: 系统在此状态下不能执行的操作
  必须行为: 系统在此状态下必须执行的操作

状态转换:
  触发条件: 导致状态变化的事件
  转换规则: 状态之间的合法转换路径
  转换效果: 状态变化带来的影响
```

#### 实用示例

**用户状态管理**：
```yaml
## State-driven Requirements
- 当用户处于未认证状态时，系统必须限制访问受保护资源
- 当用户处于未验证状态时，系统必须禁止发布内容
- 当用户处于 VIP 状态时，系统必须提供专属功能
- 当用户处于锁定状态时，系统必须拒绝所有操作请求
- 当用户处于试用期状态时，系统必须限制高级功能使用
- 当用户处于已认证状态时，系统必须允许访问个人资源
```

**业务流程控制**：
```yaml
## State-driven Requirements
- 当订单处于待支付状态时，系统必须禁止修改订单内容
- 当订单处于已发货状态时，系统必须禁止取消订单
- 当订单处于退款处理状态时，系统必须冻结相关资金
- 当商品处于下架状态时，系统必须禁止购买操作
- 当活动处于未开始状态时，系统必须隐藏活动内容
- 当项目处于已归档状态时，系统必须禁止编辑操作
```

**系统状态管理**：
```yaml
## State-driven Requirements
- 当系统处于维护模式时，系统必须拒绝写操作请求
- 当系统处于降级模式时，系统必须禁用非核心功能
- 当系统处于离线模式时，系统必须使用本地缓存
- 当系统处于高负载状态时，系统必须启用请求队列
- 当系统处于安全模式时，系统必须加强身份验证
- 当系统处于调试模式时，系统必须记录详细日志
```

#### 复杂状态场景

**状态组合**：
```yaml
## State-driven Requirements
- 当用户是管理员且系统处于维护模式时，系统必须允许系统配置修改
- 当订单是高风险且处于待审核状态时，系统必须要求人工审核
- 当系统是测试环境且用户是测试人员时，系统必须允许测试数据操作
```

**状态依赖**：
```yaml
## State-driven Requirements
- 当用户账户未激活时，系统必须限制敏感操作，即使已通过身份验证
- 当商品库存为 0 时，系统必须禁止加入购物车，即使商品已上架
- 当系统备份进行中时，系统必须禁止数据修改，即使系统正常运行
```

#### 使用场景

| 状态类型 | 示例 | 应用场景 |
|----------|------|----------|
| 权限控制 | 当用户未认证时 | 访问控制 |
| 业务流程 | 当订单待支付时 | 流程管理 |
| 系统模式 | 当系统维护时 | 运维管理 |
| 数据生命周期 | 当数据已归档时 | 数据管理 |
| 功能开关 | 当功能关闭时 | 功能管理 |

#### 编写技巧

**✅ 好的实践**：
```yaml
# 明确定义状态
- 当用户处于"未验证邮箱"状态时，系统必须限制高级功能

# 清晰的约束行为
- 当订单处于"已发货"状态时，系统必须禁止修改收货地址

# 考虑状态转换
- 当用户从"普通"升级到"VIP"状态时，系统必须立即开通专属功能

# 处理边界情况
- 当系统处于"只读"模式时，系统必须允许查询但禁止任何修改操作
```

**<span class="material-icons">cancel</span> 避免的做法**：
```yaml
# 状态定义模糊
- 当用户有问题时，系统要限制

# 约束行为不明确
- 当系统忙时，系统要控制

# 忽略状态转换
- 当状态改变时，系统要更新

# 混淆多种状态
- 当用户或系统有问题时，系统要处理
```

---

### 4. Optional Requirements（可选需求）

#### 语法结构
```
如果 [可选条件]，系统可以 [可选功能]
如果 [可选条件]，系统可能 [可选功能]
```

#### 模式特征
- **可选性**：不是必须实现的功能
- **增强性**：为系统增加价值
- **灵活性**：可以根据资源和优先级选择实现

#### 详细语法规则
```yaml
条件类型:
  配置条件: "如果配置了 [组件/服务]"
  环境条件: "如果环境支持 [技术/功能]"
  业务条件: "如果业务需要 [功能]"
  用户条件: "如果用户选择 [选项]"
  资源条件: "如果有足够的 [资源]"

情态动词:
  可以: 表示有能力实现，建议实现
  可能: 表示有实现可能性，优先级较低

可选程度:
  高优先级: 建议尽快实现
  中优先级: 有价值，可以安排实现
  低优先级: 锦上添花，有时间再实现
```

#### 实用示例

**系统集成选项**：
```yaml
## Optional Requirements
- 如果配置了邮件服务，系统可以发送通知邮件
- 如果集成了第三方登录，系统可以支持 OAuth 认证
- 如果接入了支付网关，系统可以处理在线支付
- 如果配置了短信服务，系统可以发送短信验证码
- 如果支持云存储，系统可以存储文件到云端
- 如果启用了缓存服务，系统可以提高响应速度
```

**功能增强选项**：
```yaml
## Optional Requirements
- 如果用户上传了头像，系统可以显示用户头像
- 如果用户设置了偏好，系统可以个性化界面显示
- 如果支持多语言，系统可以切换界面语言
- 如果启用实时通知，系统可以推送即时消息
- 如果支持批量操作，系统可以处理批量请求
- 如果提供了数据导出，系统可以生成报告文件
```

**技术优化选项**：
```yaml
## Optional Requirements
- 如果资源充足，系统可以实现实时协作功能
- 如果支持 CDN，系统可以加速静态资源加载
- 如果使用了消息队列，系统可以异步处理任务
- 如果启用了全文搜索，系统可以提供高级搜索功能
- 如果支持分布式架构，系统可以提高可用性
- 如果实现了缓存策略，系统可以减少数据库压力
```

#### 渐进式实现

**分阶段实现**：
```yaml
## Optional Requirements
# 第一阶段（MVP）
- 如果基本功能完成，系统可以添加简单日志

# 第二阶段（增强）
- 如果用户反馈积极，系统可以添加高级功能

# 第三阶段（优化）
- 如果系统稳定运行，系统可以添加性能优化

# 第四阶段（扩展）
- 如果业务扩展，系统可以添加集成功能
```

**条件依赖**：
```yaml
## Optional Requirements
- 如果用户数量超过 1000，系统可以启用负载均衡
- 如果数据量超过 1TB，系统可以实施数据分区
- 如果 API 调用超过 QPS 限制，系统可以启用限流机制
- 如果响应时间超过阈值，系统可以启用缓存策略
```

#### 使用场景

| 实现类型 | 示例 | 决策因素 |
|----------|------|----------|
| 技术集成 | 如果支持 Redis | 技术栈兼容性 |
| 功能增强 | 如果用户需要 | 用户需求 |
| 性能优化 | 如果资源允许 | 成本效益 |
| 扩展功能 | 如果业务发展 | 业务价值 |
| 安全增强 | 如果合规要求 | 风险评估 |

#### 编写技巧

**✅ 好的实践**：
```yaml
# 明确的前置条件
- 如果配置了 Redis 缓存服务，系统可以实现查询结果缓存

# 清晰的价值说明
- 如果支持实时协作，系统可以提供更好的团队协作体验

# 考虑实现成本
- 如果开发资源充足，系统可以实现高级数据分析功能

# 分阶段实现
- 如果第一版本发布成功，系统可以在第二版本添加移动端支持
```

**<span class="material-icons">cancel</span> 避免的做法**：
```yaml
# 条件模糊
- 如果可能，系统可以添加新功能

# 价值不明确
- 如果有时间，系统可以做些改进

# 忽略成本
- 如果用户喜欢，系统可以添加所有功能

# 无序添加
- 系统可以添加这个功能，也可以添加那个功能
```

---

### 5. Constraints（约束）

#### 语法结构
```
[约束对象] 必须 [约束条件]
[约束对象] 不应该 [禁止条件]
```

#### 模式特征
- **限制性**：对系统行为的限制
- **必要性**：必须遵守的规则
- **质量性**：保证系统质量的约束

#### 详细语法规则
```yaml
约束类型:
  必须约束: "必须 [约束条件]" - 强制性要求
  禁止约束: "不应该 [禁止条件]" - 严格禁止的行为
  推荐约束: "建议 [约束条件]" - 最佳实践

约束对象:
  数据约束: 用户输入、数据格式、数据大小、数据结构
  性能约束: 响应时间、并发数、吞吐量、资源使用
  安全约束: 访问控制、数据加密、身份验证、审计
  业务约束: 业务规则、合规要求、政策限制
  技术约束: 技术标准、架构限制、兼容性要求

约束强度:
  强制性: 必须、不应该、禁止
  推荐性: 应该、建议、推荐
  可选性: 可以、可能、最好
```

#### 实用示例

**数据验证约束**：
```yaml
## Constraints
- 用户密码长度必须在 8-128 字符之间
- 用户名必须是唯一的
- 邮箱地址必须是有效的格式
- 手机号码必须符合国际格式
- 文件上传大小不能超过 100MB
- 图片格式必须是 JPEG、PNG 或 GIF
- 用户年龄必须大于 18 岁
- 订单金额不能为负数
```

**性能约束**：
```yaml
## Constraints
- API 响应时间不应该超过 2 秒
- 页面加载时间不应该超过 3 秒
- 系统必须支持至少 1000 并发用户
- 数据库查询时间不应该超过 100ms
- 文件上传速度不应该低于 1MB/s
- 搜索响应时间不应该超过 500ms
- 系统可用性必须达到 99.9%
- 内存使用不应该超过 80%
```

**安全约束**：
```yaml
## Constraints
- 用户密码必须使用 bcrypt 加密存储
- API 通信必须使用 HTTPS 协议
- 敏感数据不应该在日志中显示
- 系统必须每 60 分钟更新一次会话令牌
- 用户登录失败次数不应该超过 5 次
- 数据库访问必须使用参数化查询
- 系统必须定期备份用户数据
- 管理员操作必须记录审计日志
```

**业务约束**：
```yaml
## Constraints
- 订单金额不能超过信用额度
- 商品库存不能为负数
- 折扣率必须在 0-100% 之间
- 促销活动开始时间不能晚于结束时间
- 用户账户余额不能透支
- 退款金额不能超过原订单金额
- VIP 用户享受的折扣率不能超过 50%
- 会员积分不能为负数
```

**技术约束**：
```yaml
## Constraints
- 系统必须兼容 Chrome、Firefox、Safari 最新版本
- API 版本必须向后兼容
- 数据库表名必须使用小写字母和下划线
- 代码覆盖率不应该低于 80%
- 系统必须支持 IPv4 和 IPv6
- 客户端必须支持离线缓存
- API 响应必须使用 JSON 格式
- 所有 HTTP 状态码必须符合标准
```

#### 约束的层次结构

**系统级约束**：
```yaml
## Constraints
- 系统必须遵守 GDPR 数据保护法规
- 系统必须实现 SOC 2 安全标准
- 系统必须符合 PCI DSS 支付安全标准
- 系统必须支持无障碍访问标准
```

**模块级约束**：
```yaml
## Constraints
- 用户认证模块必须支持多因子认证
- 支付模块必须支持 PCI DSS 合规
- 日志模块必须符合 GDPR 数据保留要求
- 缓存模块必须支持 Redis 集群
```

**功能级约束**：
```yaml
## Constraints
- 密码重置链接必须在 24 小时内有效
- 用户头像文件大小不能超过 5MB
- 搜索结果每页必须显示 10-50 条记录
- 购物车商品数量不能超过 99 件
```

#### 使用场景

| 约束类型 | 示例 | 应用场景 |
|----------|------|----------|
| 数据完整性 | 邮箱必须有效 | 数据验证 |
| 性能标准 | 响应时间 < 2s | 性能优化 |
| 安全要求 | 密码必须加密 | 安全保护 |
| 合规要求 | 必须符合 GDPR | 法规遵循 |
| 用户体验 | 界面必须响应式 | 可用性 |

#### 编写技巧

**✅ 好的实践**：
```yaml
# 具体可测量
- API 响应时间必须在 95% 的情况下小于 200ms

# 明确边界
- 用户名长度必须在 3-30 个字符之间

# 考虑异常情况
- 系统不应该暴露敏感的错误信息

- 包含验证方法
- 用户密码必须包含至少一个数字和一个特殊字符
```

**<span class="material-icons">cancel</span> 避免的做法**：
```yaml
# 模糊不清
- 系统应该运行良好

- 无法验证
- 用户体验应该不错

- 缺少边界
- 密码长度要合适

- 过于严格
- 所有输入都必须完美无缺
```

---

## EARS 语法最佳实践

### 1. 选择合适的模式

#### 决策流程图
```mermaid
%%{init: {'theme':'neutral'}}%%
flowchart TD
    A[需求描述] --> B{是否需要触发条件？}
    B -->|是| C{是事件触发还是状态依赖？}
    B -->|否| D{是系统必须具备的功能吗？}

    C -->|事件触发| E[Event-driven Requirements]
    C -->|状态依赖| F[State-driven Requirements]

    D -->|是| G[Ubiquitous Requirements]
    D -->|否| H{是可选功能吗？}

    H -->|是| I[Optional Requirements]
    H -->|否| J[Constraints]

    E --> K[当 [条件] 时，系统必须 [响应]]
    F --> L[当 [状态] 时，系统必须 [行为]]
    G --> M[系统必须 [功能]]
    I --> N[如果 [条件]，系统可以 [功能]]
    J --> O[对象 必须/不应该 [约束]]
```

#### 选择指南

| 需求特征 | 推荐模式 | 示例 |
|----------|----------|------|
| 系统基本功能 | Ubiquitous | 系统必须支持用户注册 |
| 用户操作触发 | Event-driven | 当用户点击登录时 |
| 权限或状态限制 | State-driven | 当用户未认证时 |
| 增强或可选功能 | Optional | 如果支持第三方登录 |
| 规则或限制 | Constraints | 密码长度必须 8-128 位 |

### 2. 编写高质量需求

#### 清晰性原则

**使用精确词汇**：
```yaml
# ✅ 使用精确动词
- 系统必须验证用户输入的邮箱格式
- 系统必须记录所有登录尝试
- 系统必须缓存频繁访问的数据

# <span class="material-icons">cancel</span> 避免模糊动词
- 系统要处理用户输入
- 系统要注意登录情况
- 系统要优化性能
```

**明确时间要求**：
```yaml
# ✅ 包含时间约束
- 系统必须在 2 秒内完成用户认证
- 系统应该在 5 分钟内发送验证邮件
- 系统必须每 24 小时备份一次数据

# <span class="material-icons">cancel</span> 缺少时间要求
- 系统要快速完成认证
- 系统要尽快发送邮件
- 系统要定期备份数据
```

#### 完整性原则

**包含所有必要条件**：
```yaml
# ✅ 完整的触发条件
- 当用户提供有效的邮箱和符合密码强度规则的密码时，系统必须创建用户账户并发送验证邮件

# <span class="material-icons">cancel</span> 条件不完整
- 当用户注册时，系统要创建账户
```

**考虑边界情况**：
```yaml
# ✅ 包含边界处理
- 当用户连续输入错误密码 5 次时，系统必须锁定账户 15 分钟
- 当用户在 24 小时内尝试登录失败 10 次时，系统必须永久锁定账户

# <span class="material-icons">cancel</span> 忽略边界情况
- 当用户密码错误时，系统要提示错误
```

### 3. 需求验证技巧

#### 可测试性检查

**自动验证清单**：
```yaml
验证问题:
  1. 需求是否可以用测试用例验证？
  2. 验收标准是否明确可测量？
  3. 边界条件是否已定义？
  4. 异常情况是否已考虑？
  5. 性能指标是否可量化？

# 示例验证
需求: 当用户登录时，系统必须记录登录日志

验证测试:
- Given 用户输入正确凭证
- When 用户点击登录按钮
- Then 系统必须记录包含用户ID、IP地址、时间戳的登录日志
- And 日志必须存储到数据库的 login_logs 表
```

#### 一致性检查

**需求一致性矩阵**：
```yaml
一致性检查项目:
  术语一致性: 同一概念使用相同术语
  逻辑一致性: 需求间无逻辑冲突
  完整性: 需求覆盖所有功能场景
  可追溯性: 需求可追溯到业务目标

# 检查示例
✅ 用户认证相关的需求都使用"用户"而不是"客户"
✅ 登录和注销的需求逻辑一致
✅ 覆盖了注册、登录、重置密码等完整流程
✅ 每个需求都能对应到具体的业务价值
```

### 4. 常见错误和避免方法

#### 语法错误

**<span class="material-icons">cancel</span> 常见语法错误**：
```yaml
# 1. 缺少主语
- 应该支持用户注册
- 必须验证输入

# 2. 条件和响应不匹配
- 当用户输入密码时，密码必须加密
- 当系统启动时，用户必须登录

# 3. 使用模糊词汇
- 系统要尽快处理
- 功能应该比较好用
- 建议适当优化
```

**✅ 正确的语法**：
```yaml
# 1. 完整的主谓宾结构
- 系统必须支持用户注册功能
- 系统必须验证用户输入

# 2. 逻辑匹配的条件和响应
- 当用户设置密码时，系统必须使用 bcrypt 加密存储
- 当系统启动时，系统必须初始化所有必要服务

# 3. 使用明确的词汇
- 系统必须在 2 秒内处理请求
- 系统必须提供直观的用户界面
- 建议使用 Redis 缓存提高性能
```

#### 逻辑错误

**<span class="material-icons">cancel</span> 常见逻辑错误**：
```yaml
# 1. 循环依赖
- 当用户登录时，系统必须验证邮箱
- 当邮箱验证时，系统必须要求用户登录

# 2. 矛盾条件
- 系统必须支持匿名访问
- 当用户未认证时，系统必须拒绝所有访问

# 3. 无法实现的需求
- 系统必须 100% 可用
- 系统必须立即响应所有请求
```

**✅ 正确的逻辑**：
```yaml
# 1. 清晰的流程
- 当用户注册时，系统必须创建账户并发送验证邮件
- 当用户验证邮箱时，系统必须激活账户

# 2. 一致的权限控制
- 系统必须支持匿名访问公开内容
- 当用户未认证时，系统必须限制访问受保护资源

# 3. 可实现的性能要求
- 系统可用性必须达到 99.9%
- 系统必须在 2 秒内响应请求
```

---

## EARS 与测试驱动开发

### 1. 从 EARS 到测试用例

#### 转换映射表
```yaml
EARS 模式 → 测试类型:

Ubiquitous Requirements:
  "系统必须支持用户注册"
  → 功能测试: 测试用户注册流程

Event-driven Requirements:
  "当用户登录时，系统必须记录日志"
  → 集成测试: 测试登录事件触发日志记录

State-driven Requirements:
  "当用户未认证时，系统必须限制访问"
  → 状态测试: 测试不同状态下的访问控制

Optional Requirements:
  "如果支持邮件服务，系统可以发送通知"
  → 条件测试: 测试可选功能在不同条件下的行为

Constraints:
  "密码长度必须在 8-128 字符之间"
  → 验证测试: 测试输入验证规则
```

#### 实际转换示例

**原始需求**：
```yaml
## Event-driven Requirements
- 当用户提供有效邮箱和密码时，系统必须发放 JWT 令牌
- 当 JWT 令牌过期时，系统必须要求重新登录

## State-driven Requirements
- 当用户处于未认证状态时，系统必须限制访问受保护资源
- 当用户处于已认证状态时，系统必须允许访问用户资源

## Constraints
- JWT 令牌有效期不能超过 24 小时
- API 响应时间不应该超过 200 毫秒
```

**对应测试用例**：
```python
# test_authentication.py
import pytest
from datetime import datetime, timedelta

class TestAuthentication:
    def test_user_login_with_valid_credentials(self):
        """当用户提供有效邮箱和密码时，系统必须发放 JWT 令牌"""
        # Given 有效用户凭证
        email = "user@example.com"
        password = "valid_password"

        # When 用户登录
        response = client.post("/api/login", json={
            "email": email,
            "password": password
        })

        # Then 系统必须发放 JWT 令牌
        assert response.status_code == 200
        assert "access_token" in response.json()
        assert len(response.json()["access_token"]) > 0

    def test_jwt_token_expiration(self):
        """当 JWT 令牌过期时，系统必须要求重新登录"""
        # Given 过期的 JWT 令牌
        expired_token = create_expired_token()

        # When 使用过期令牌访问受保护资源
        response = client.get("/api/user/profile", headers={
            "Authorization": f"Bearer {expired_token}"
        })

        # Then 系统必须要求重新登录
        assert response.status_code == 401
        assert response.json()["error"] == "Token expired"

    def test_unauthenticated_user_access_restriction(self):
        """当用户处于未认证状态时，系统必须限制访问受保护资源"""
        # When 未认证用户访问受保护资源
        response = client.get("/api/user/profile")

        # Then 系统必须限制访问
        assert response.status_code == 401
        assert response.json()["error"] == "Authentication required"

    def test_authenticated_user_access_allowed(self):
        """当用户处于已认证状态时，系统必须允许访问用户资源"""
        # Given 已认证用户
        token = authenticate_user()

        # When 访问用户资源
        response = client.get("/api/user/profile", headers={
            "Authorization": f"Bearer {token}"
        })

        # Then 系统必须允许访问
        assert response.status_code == 200
        assert "user_data" in response.json()

    def test_jwt_token_max_validity(self):
        """JWT 令牌有效期不能超过 24 小时"""
        # When 创建 JWT 令牌
        token = create_jwt_token()

        # Then 令牌有效期不能超过 24 小时
        payload = decode_jwt_token(token)
        expiration_time = datetime.fromtimestamp(payload["exp"])
        creation_time = datetime.fromtimestamp(payload["iat"])

        assert (expiration_time - creation_time) <= timedelta(hours=24)

    def test_api_response_time_constraint(self):
        """API 响应时间不应该超过 200 毫秒"""
        # When 执行 API 请求
        start_time = datetime.now()
        response = client.post("/api/login", json={
            "email": "user@example.com",
            "password": "password"
        })
        end_time = datetime.now()

        # Then 响应时间不应该超过 200 毫秒
        response_time = (end_time - start_time).total_seconds() * 1000
        assert response_time <= 200
        assert response.status_code == 200
```

### 2. TDD 循环中的 EARS

#### RED 阶段：基于 EARS 编写失败的测试

```python
# Step 1: 根据 EARS 需求编写测试
def test_user_registration_email_validation():
    """
    基于 EARS 需求：
    当用户注册时，系统必须验证邮箱格式
    邮箱地址必须是有效的格式
    """
    # Given 用户提供无效邮箱
    invalid_emails = [
        "invalid-email",
        "@example.com",
        "user@",
        "user..name@example.com"
    ]

    for invalid_email in invalid_emails:
        # When 用户尝试注册
        response = client.post("/api/register", json={
            "email": invalid_email,
            "password": "ValidPassword123!"
        })

        # Then 系统必须拒绝注册
        assert response.status_code == 400
        assert "Invalid email format" in response.json()["error"]
```

#### GREEN 阶段：最小实现满足测试

```python
# Step 2: 最小实现通过测试
@app.route("/api/register", methods=["POST"])
def register():
    data = request.get_json()
    email = data.get("email")
    password = data.get("password")

    # 最小邮箱验证实现
    if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
        return jsonify({"error": "Invalid email format"}), 400

    # 其他基本验证...
    return jsonify({"message": "Registration successful"}), 201
```

#### REFACTOR 阶段：优化实现

```python
# Step 3: 重构为更好的实现
def validate_email_format(email: str) -> bool:
    """验证邮箱格式的优化实现"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_password_strength(password: str) -> dict:
    """验证密码强度"""
    errors = []
    if len(password) < 8:
        errors.append("Password must be at least 8 characters")
    if not re.search(r"[A-Z]", password):
        errors.append("Password must contain uppercase letter")
    if not re.search(r"[a-z]", password):
        errors.append("Password must contain lowercase letter")
    if not re.search(r"\d", password):
        errors.append("Password must contain digit")
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        errors.append("Password must contain special character")

    return {"valid": len(errors) == 0, "errors": errors}

@app.route("/api/register", methods=["POST"])
def register():
    """优化的注册端点"""
    data = request.get_json()
    email = data.get("email")
    password = data.get("password")

    # 验证邮箱格式
    if not validate_email_format(email):
        return jsonify({"error": "Invalid email format"}), 400

    # 验证密码强度
    password_validation = validate_password_strength(password)
    if not password_validation["valid"]:
        return jsonify({
            "error": "Password requirements not met",
            "details": password_validation["errors"]
        }), 400

    # 创建用户逻辑...
    return jsonify({"message": "Registration successful"}), 201
```

### 3. 测试覆盖率与 EARS 对应

#### 覆盖率矩阵
```yaml
需求类型 测试覆盖:

Ubiquitous Requirements:
  需求: "系统必须支持用户注册"
  测试覆盖:
    - 正常注册流程测试
    - 注册数据验证测试
    - 注册异常处理测试
  覆盖率目标: 100%

Event-driven Requirements:
  需求: "当用户登录时，系统必须记录日志"
  测试覆盖:
    - 登录成功日志记录测试
    - 登录失败日志记录测试
    - 日志格式验证测试
  覆盖率目标: 100%

State-driven Requirements:
  需求: "当用户未认证时，系统必须限制访问"
  测试覆盖:
    - 未认证访问限制测试
    - 权限边界测试
    - 状态转换测试
  覆盖率目标: 95%

Optional Requirements:
  需求: "如果支持邮件服务，系统可以发送通知"
  测试覆盖:
    - 邮件服务可用时测试
    - 邮件服务不可用时测试
    - 邮件发送失败处理测试
  覆盖率目标: 80%

Constraints:
  需求: "密码长度必须在 8-128 字符之间"
  测试覆盖:
    - 最小长度边界测试
    - 最大长度边界测试
    - 超出范围测试
  覆盖率目标: 100%
```

---

## EARS 语法的实际应用

### 1. 电商系统示例

#### 用户管理模块
```yaml
# User Management EARS Requirements

## Ubiquitous Requirements
- 系统必须提供用户注册功能
- 系统必须提供用户登录功能
- 系统必须提供密码重置功能
- 系统必须记录用户操作日志
- 系统必须保护用户隐私数据

## Event-driven Requirements
- 当用户提供有效注册信息时，系统必须创建用户账户
- 当用户注册成功时，系统必须发送欢迎邮件
- 当用户登录时，系统必须验证身份并创建会话
- 当用户连续登录失败 5 次时，系统必须锁定账户
- 当用户请求密码重置时，系统必须发送重置邮件
- 当用户点击重置链接时，系统必须允许设置新密码

## State-driven Requirements
- 当用户处于未激活状态时，系统必须限制购买功能
- 当用户处于 VIP 状态时，系统必须提供专属折扣
- 当用户处于锁定状态时，系统必须拒绝所有操作
- 当用户处于未验证邮箱状态时，系统必须限制敏感操作

## Optional Requirements
- 如果用户提供了头像，系统可以显示用户头像
- 如果支持第三方登录，系统可以集成 OAuth 提供商
- 如果用户设置了偏好，系统可以个性化推荐商品
- 如果启用了双重认证，系统可以要求验证码

## Constraints
- 用户名必须是唯一的
- 密码长度必须在 8-128 字符之间
- 邮箱地址必须是有效的格式
- 手机号码必须符合国际格式
- 用户年龄必须大于 18 岁
```

#### 订单管理模块
```yaml
# Order Management EARS Requirements

## Ubiquitous Requirements
- 系统必须支持订单创建功能
- 系统必须支持订单查询功能
- 系统必须支持订单状态更新
- 系统必须记录订单变更历史
- 系统必须计算订单总价

## Event-driven Requirements
- 当用户添加商品到购物车时，系统必须更新购物车信息
- 当用户提交订单时，系统必须验证库存并创建订单
- 当支付成功时，系统必须更新订单状态为已支付
- 当商家发货时，系统必须更新订单状态并通知用户
- 当用户确认收货时，系统必须更新订单状态为已完成
- 当用户申请退款时，系统必须创建退款请求

## State-driven Requirements
- 当订单处于待支付状态时，系统必须禁止修改订单内容
- 当订单处于已支付状态时，系统必须禁止取消订单
- 当订单处于配送中状态时，系统必须禁止修改收货地址
- 当订单处于已完成状态时，系统必须允许用户评价商品
- 当订单处于退款处理状态时，系统必须冻结相关资金

## Optional Requirements
- 如果用户是 VIP，系统可以提供免费配送服务
- 如果商品参与促销活动，系统可以自动应用折扣
- 如果库存不足，系统可以推荐类似商品
- 如果用户地址偏远，系统可以计算额外运费

## Constraints
- 订单金额不能为负数
- 商品库存不能为负数
- 折扣金额不能超过商品原价
- 订单编号必须是唯一的
- 配送时间必须在合理范围内
```

### 2. API 设计示例

#### RESTful API 规范
```yaml
# RESTful API EARS Requirements

## Ubiquitous Requirements
- 系统必须遵循 RESTful 设计原则
- 系统必须使用标准的 HTTP 状态码
- 系统必须提供一致的 API 响应格式
- 系统必须支持 API 版本管理
- 系统必须实现适当的 HTTP 缓存策略

## Event-driven Requirements
- 当客户端发送 GET 请求时，系统必须返回资源表示
- 当客户端发送 POST 请求时，系统必须创建新资源
- 当客户端发送 PUT 请求时，系统必须更新完整资源
- 当客户端发送 PATCH 请求时，系统必须部分更新资源
- 当客户端发送 DELETE 请求时，系统必须删除指定资源
- 当 API 请求无效时，系统必须返回 400 错误状态码

## State-driven Requirements
- 当资源不存在时，系统必须返回 404 状态码
- 当客户端未认证时，系统必须返回 401 状态码
- 当客户端权限不足时，系统必须返回 403 状态码
- 当 API 版本过时，系统必须返回 410 状态码
- 当服务器内部错误时，系统必须返回 500 状态码

## Optional Requirements
- 如果客户端请求特定格式，系统可以支持 XML 响应
- 如果支持实时更新，系统可以提供 WebSocket 连接
- 如果 API 调用频繁，系统可以实现速率限制
- 如果需要复杂查询，系统可以提供 GraphQL 接口

## Constraints
- API 响应时间不应该超过 2000 毫秒
- 单次 API 调用返回的数据量不能超过 10MB
- API 必须支持 HTTPS 协议
- API 必须包含适当的错误信息
- API 必须提供完整的文档
```

### 3. 微服务架构示例

#### 服务通信规范
```yaml
# Microservices Communication EARS Requirements

## Ubiquitous Requirements
- 系统必须使用轻量级通信协议
- 系统必须实现服务发现机制
- 系统必须提供健康检查端点
- 系统必须支持分布式配置管理
- 系统必须实现服务熔断机制

## Event-driven Requirements
- 当服务启动时，系统必须注册到服务发现中心
- 当服务停止时，系统必须从服务发现中心注销
- 当服务调用失败时，系统必须触发熔断机制
- 当配置更新时，系统必须重新加载配置
- 当服务健康检查失败时，系统必须从负载均衡器中移除

## State-driven Requirements
- 当服务处于降级状态时，系统必须禁用非核心功能
- 当服务处于维护模式时，系统必须拒绝写操作请求
- 当服务间网络延迟超过阈值时，系统必须启用本地缓存
- 当服务负载过高时，系统必须启用限流机制

## Optional Requirements
- 如果支持异步通信，系统可以使用消息队列
- 如果需要实时通信，系统可以使用事件流处理
- 如果要求高性能，系统可以实现服务网格
- 如果需要数据一致性，系统可以使用分布式事务

## Constraints
- 服务间调用延迟不应该超过 100 毫秒
- 服务响应时间不应该超过 500 毫秒
- 服务可用性必须达到 99.9%
- 服务必须支持水平扩展
- 服务必须实现幂等性
```

---

## 总结

EARS 语法为 MoAI-ADK 中的需求工程提供了强大的工具：

### 1. 五种模式的优势

- **Ubiquitous Requirements**：定义系统核心功能，确保基础能力完备
- **Event-driven Requirements**：描述交互行为，明确因果关系
- **State-driven Requirements**：控制权限和流程，管理状态转换
- **Optional Requirements**：提供灵活性，支持渐进式实现
- **Constraints**：保证质量标准，确保系统安全可靠

### 2. 关键实践原则

1. **选择合适的模式**：根据需求特征选择最匹配的 EARS 模式
2. **保持语法正确**：遵循标准句式结构，确保无歧义表达
3. **确保可测试性**：每个需求都能转化为具体的测试用例
4. **维护一致性**：术语、逻辑、格式保持统一
5. **考虑边界情况**：覆盖异常条件和特殊场景

### 3. 与 TDD 的完美结合

- **需求到测试**：EARS 需求可以直接转化为测试用例
- **完整覆盖**：五种模式覆盖所有类型的功能需求
- **质量保证**：通过约束确保系统质量标准
- **持续改进**：基于测试反馈不断优化需求表达

### 4. 团队协作价值

- **统一语言**：团队成员使用相同的需求表达方式
- **减少误解**：标准化语法减少沟通成本
- **提高效率**：自动化工具支持需求分析和验证
- **知识传承**：新成员更容易理解现有需求

通过掌握 EARS 语法，您可以编写出清晰、完整、可测试的需求文档，为高质量软件开发奠定坚实基础。

### 下一步

- [学习 SPEC 标签系统](tags.md)
- [查看 SPEC 编写示例](examples.md)
- [掌握 TDD 实践方法](../tdd/)
- [开始使用 Alfred 命令](../alfred/1-plan.md)

通过熟练应用 EARS 语法，您将能够编写出专业级的需求文档，确保项目成功的每一个细节都得到充分考虑。