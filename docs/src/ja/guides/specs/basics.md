# SPEC作成の基礎

EARS (Easy Approach to Requirements Syntax)形式を使用して、明確で実行可能な仕様を作成する方法を学びましょう。良い仕様は、ソフトウェア開発成功の基盤です。

## 概要

MoAI-ADKのSPEC (仕様書)は、何を作るべきか、どのように動作すべきか、どのような制約が適用されるかを定義する構造化されたドキュメントです。SPECはEARS方法論に従い、明確性、テスト可能性、完全性を保証します。

### 良いSPECとは?

- **明確**: 解釈の余地がない明確な言語
- **テスト可能**: 各要件がテストを通じて検証可能
- **完全**: 機能のすべての側面をカバー
- **追跡可能**: TAGを通じてテスト、コード、ドキュメントと連携
- **保守可能**: 要件が進化しても理解と修正が容易

### SPEC-First原則

> 「仕様なしにコードなし、明確な要件なしにテストなし」

SPECは**コード作成前**に作成され、全員が何を作るべきか、成功をどう測定するかを正確に理解することを保証します。

## SPEC構造とコンポーネント

### YAMLフロントマター

すべてのSPECは構造化されたメタデータで始まります:

```yaml
---
id: AUTH-001
version: 0.1.0
status: draft
priority: high
created: 2025-01-15
updated: 2025-01-15
author: @developer
domain: authentication
complexity: medium
estimated_hours: 8
dependencies: [USER-001, EMAIL-001]
tags: [api, security, jwt]
reviewers: [@tech-lead, @security-expert]
milestone: "Sprint 23 - Q1 2025"
---
```

**フィールド説明**:

- **`id`**: `DOMAIN-NNN`形式の一意識別子
- **`version`**: `MAJOR.MINOR.PATCH`に従うセマンティックバージョン
- **`status`**: 現在の状態 (draft, in_review, approved, in_progress, completed, stable, deprecated)
- **`priority`**: 重要度レベル (critical, high, medium, low)
- **`domain`**: 機能領域 (authentication, user_management, api, database, 等)
- **`complexity`**: 実装難易度 (simple, medium, complex, expert)
- **`estimated_hours`**: 実装時間の見積もり
- **`dependencies`**: このSPECが依存する他のSPEC
- **`tags`**: 分類と検索のためのキーワード
- **`reviewers`**: このSPECをレビューすべきチームメンバー
- **`milestone`**: 開発マイルストーンまたはスプリント

### SPECコンテンツセクション

完全なSPECには以下のセクションが含まれます:

```markdown
# @SPEC:EX-AUTH-001: ユーザー認証システム

## 概要
このSPECがカバーする内容とその重要性の簡単な説明。

## EARS要件
EARS形式で書かれた核心要件。

## 技術要件
非機能要件と技術制約。

## 受け入れ基準
完了のために満たすべき具体的な条件。

## 依存関係
このSPECが依存する他のコンポーネント、システム、SPEC。

## リスク評価
潜在的な課題と緩和戦略。

## 実装ノート
専門家からの技術的考慮事項と推薦。
```

## EARS構文: 5つのパターン

EARS (Easy Approach to Requirements Syntax)は、要件を書くための5つの明確なパターンを提供します。各パターンには特定の目的があり、一貫した言語を使用します。

### 1. 遍在要件 (Ubiquitous Requirements)

**目的**: 常に利用可能であるべき基本機能を定義。

**パターン**: `システムは<能力>を提供すべきである`

**例**:

```markdown
- システムはメールとパスワードによるユーザー認証を提供すべきである
- システムはJWTトークンベースのセッション管理をサポートすべきである
- システムは処理前にユーザー入力を検証すべきである
- システムはすべての認証試行を記録すべきである
- システムはユーザーセッション状態を安全に維持すべきである
```

**特徴**:

- 常に有効な機能
- システムの核心能力
- 条件やトリガーなし
- システム動作に必須

### 2. イベント駆動要件 (Event-driven Requirements)

**目的**: 特定のイベントやトリガーへの応答としてシステムの動作を定義。

**パターン**: `WHEN <トリガーが発生>、システムは<応答>すべきである`

**例**:

```markdown
- WHEN 有効な認証情報が提供されたら、システムはアクセストークンとリフレッシュトークンを発行すべきである
- WHEN 無効な認証情報が提供されたら、システムは401エラーを返すべきである
- WHEN リフレッシュトークンが有効なら、システムは新しいアクセストークンを発行すべきである
- WHEN 複数回のログイン失敗が発生したら、システムはレート制限を実装すべきである
- WHEN ユーザーがログアウトしたら、システムはすべてのアクティブトークンを無効化すべきである
```

**特徴**:

- 明確なトリガー-応答関係
- イベント駆動の動作
- 特定の条件と結果
- テスト可能なシナリオ

### 3. 状態駆動要件 (State-driven Requirements)

**目的**: システム状態や条件に依存する動作を定義。

**パターン**: `WHILE <条件が存在>、システムは<動作>すべきである`

**例**:

```markdown
- WHILE ユーザーが認証されている時、システムは保護されたリソースへのアクセスを許可すべきである
- WHILE セッションがアクティブな時、システムはユーザーコンテキストを維持すべきである
- WHILE レート制限がアクティブな時、システムは超過リクエストを拒否すべきである
- WHILE メンテナンスモードが有効な時、システムは管理者のみアクセスを許可すべきである
- WHILE パスワードリセットが進行中な時、システムはログイン試行をブロックすべきである
```

**特徴**:

- 条件が存在する間の継続的な動作
- 状態依存の機能
- コンテキストを認識した操作
- 継続的なシステム動作

### 4. オプション要件 (Optional Requirements)

**目的**: あると良い機能や条件付き機能を定義。

**パターン**: `WHERE <条件が満たされた>、システムは<オプション動作>できる`

**例**:

```markdown
- WHERE 多要素認証が有効な時、システムは追加検証を要求できる
- WHERE ソーシャルログインプロバイダーが設定されている時、システムはOAuth認証をサポートできる
- WHERE デバイスフィンガープリンティングが利用可能な時、システムはデバイス別のログインセッションを追跡できる
- WHERE ユーザー設定で許可されている時、システムはログイン場所を記憶できる
- WHERE 分析が有効な時、システムは認証パターンを追跡できる
```

**特徴**:

- 条件付き機能
- オプション機能
- 拡張能力
- 設定依存

### 5. 望ましくない動作 (制約)

**目的**: システムが**すべきでない**ことと従うべき制約を定義。

**パターン**: `システムは<望ましくない動作>をすべきでない` または `<パラメータ>は<制約>をすべきでない`

**例**:

```markdown
- システムはパスワードを平文で保存すべきでない
- システムはメールアドレスが登録されているかどうかを明らかにすべきでない
- パスワードは8文字未満であるべきでない
- システムは同じ認証情報での同時セッションを許可すべきでない
- JWTトークンは24時間以上有効であるべきでない
- ログイン試行はIP当たり1分あたり5回を超えるべきでない
- システムはユーザー名に特殊文字を受け入れるべきでない
```

**特徴**:

- セキュリティ制約
- ビジネスルール
- 技術的制限
- 品質要件

## 効果的な要件の記述

### 要件品質チェックリスト

各要件について検証:

**明確性**:

- [ ] 言語が曖昧さなし
- [ ] 技術用語が定義されている
- [ ] 略語が説明されている
- [ ] コンテキストが明確

**テスト可能性**:

- [ ] 成功基準が定義されている
- [ ] テストシナリオを作成できる
- [ ] 期待される結果が指定されている
- [ ] エッジケースが考慮されている

**完全性**:

- [ ] すべての機能的側面がカバーされている
- [ ] エラー条件が含まれている
- [ ] パフォーマンス要件が指定されている
- [ ] セキュリティ考慮事項が対処されている

**一貫性**:

- [ ] 言語がEARSパターンに従っている
- [ ] 用語が一貫している
- [ ] 要件が矛盾していない
- [ ] 依存関係が特定されている

### 避けるべきよくある間違い

**❌ 曖昧な言語**:

```
システムはユーザー認証をうまく処理すべきである。
```

**✅ 具体的な言語**:

```
システムはメール/パスワード認証情報を通じて500ms以内にユーザーを認証すべきである。
```

**❌ 複数の要件を一つに**:

```
WHEN ユーザーがログインする時、システムはトークンを発行し、試行を記録し、ユーザープロファイルを更新すべきである。
```

**✅ 分離された要件**:

```
WHEN 有効な認証情報が提供されたら、システムはJWTトークンを発行すべきである。
WHEN 認証が発生したら、システムはタイムスタンプとともに試行を記録すべきである。
WHEN ユーザーが正常に認証されたら、システムは最終ログインタイムスタンプを更新すべきである。
```

**❌ 実装詳細**:

```
システムはPostgreSQLデータベースで12ラウンドのbcryptを使用してパスワードをハッシュすべきである。
```

**✅ 動作要件**:

```
システムは最低12ラウンドの安全なアルゴリズムを使用してパスワードをハッシュすべきである。
システムはパスワードハッシュをデータベースに安全に保存すべきである。
```

**❌ エラー条件の欠落**:

```
WHEN ユーザーが有効な認証情報でログインする時、システムはトークンを発行すべきである。
```

**✅ 完全なカバレッジ**:

```
WHEN 有効な認証情報が提供されたら、システムはJWTトークンを発行すべきである。
WHEN 無効な認証情報が提供されたら、システムは401エラーを返すべきである。
WHEN 認証サービスが利用できない時、システムは503エラーを返すべきである。
```

## SPEC ID割り当てと管理

### ID形式とルール

**形式**: `DOMAIN-NNN`

**例**: `AUTH-001`, `USER-002`, `API-003`, `DB-001`

### ドメインカテゴリ

| ドメイン   | 説明                       | 例                                 |
| ---------- | -------------------------- | ---------------------------------- |
| **AUTH**   | 認証と認可                 | ログイン、登録、権限               |
| **USER**   | ユーザー管理とプロファイル | プロファイル作成、ユーザー設定     |
| **API**    | REST APIエンドポイントとインターフェース | HTTPエンドポイント、リクエスト/レスポンス形式 |
| **DB**     | データベーススキーマと操作 | テーブル、クエリ、マイグレーション |
| **UI**     | ユーザーインターフェースコンポーネント | フォーム、ページ、インタラクション |
| **SEC**    | セキュリティ機能と管理     | 暗号化、監査、コンプライアンス     |
| **PERF**   | パフォーマンスと最適化     | キャッシング、ロードバランシング、監視 |
| **INT**    | 外部システムとの統合       | サードパーティAPI、Webhook         |
| **CONFIG** | 設定と設定                 | 環境変数、機能フラグ               |

### ID割り当てプロセス

1. **ドメイン選択**: 機能に適切なドメインを選択
2. **既存ID確認**: そのドメインで次に利用可能な番号を見つける
3. **ID割り当て**: `DOMAIN-NNN`形式を使用 (例: `AUTH-001`)
4. **レジストリに記録**: `.moai/specs/registry.json`を更新

**レジストリエントリの例**:

```json
{
  "AUTH-001": {
    "title": "ユーザー認証システム",
    "status": "completed",
    "created": "2025-01-15",
    "assigned_to": "@developer"
  },
  "AUTH-002": {
    "title": "パスワードリセット機能",
    "status": "draft",
    "created": "2025-01-16",
    "assigned_to": "@developer"
  }
}
```

## 受け入れ基準

### 効果的な受け入れ基準の記述

受け入れ基準は、SPECがいつ完了し正しく動作していると見なされるかを定義します。

#### Gherkinスタイル形式

```gherkin
Feature: ユーザー認証

Scenario: 有効な認証情報でのログイン成功
  GIVEN 有効な認証情報を持つ登録ユーザー
  WHEN ユーザーが正しいメールとパスワードを送信
  THEN システムはユーザーを認証すべきである
  AND システムはJWTトークンを発行すべきである
  AND トークンは15分間有効であるべきである

Scenario: 無効な認証情報でのログイン失敗
  GIVEN 登録ユーザーアカウント
  WHEN ユーザーが間違ったパスワードを送信
  THEN システムは認証を拒否すべきである
  AND システムは401エラーを返すべきである
  AND システムは失敗した試行を記録すべきである
```

#### チェックリスト形式

```markdown
## 受け入れ基準

### 機能要件
- [ ] ユーザーはメールとパスワードで認証できる
- [ ] システムはJWTアクセストークンを発行する (15分有効期限)
- [ ] システムはJWTリフレッシュトークンを発行する (7日有効期限)
- [ ] 無効な認証情報は401エラーを返す
- [ ] レート制限がブルートフォース攻撃を防ぐ

### セキュリティ要件
- [ ] パスワードはbcryptでハッシュされている (12以上のラウンド)
- [ ] JWTトークンはRS256署名アルゴリズムを使用
- [ ] すべてのエンドポイントはHTTPSのみを使用
- [ ] 入力検証がインジェクション攻撃を防ぐ
- [ ] 認証試行が記録される

### パフォーマンス要件
- [ ] ログイン応答時間 < 500ms
- [ ] トークン検証 < 100ms
- [ ] システムは1000の同時認証をサポート
- [ ] データベースクエリが最適化されている
```

### テスト可能な受け入れ基準

各受け入れ基準は以下であるべきです:

1. **具体的**: 明確で曖昧さなし
2. **測定可能**: 定量化または検証可能
3. **達成可能**: 現実的で達成可能
4. **関連性**: ビジネス目標と一致
5. **期限付き**: 明確な完了基準がある

## 依存関係と関係

### 依存関係の種類

**機能的依存関係**:

```markdown
## 依存関係
- USER-001: ユーザー管理システム (認証に必要)
- EMAIL-001: メールサービス (通知に必要)
- RATE-001: レート制限サービス (セキュリティに必要)
```

**技術的依存関係**:

```markdown
## 技術的依存関係
- PostgreSQLデータベース (バージョン13以上)
- セッション保存用Redis
- メール配信用SMTPサーバー
- HTTPS用SSL証明書
```

**外部依存関係**:

```markdown
## 外部依存関係
- ソーシャルログイン用OAuthプロバイダー (Google、GitHub)
- 二要素認証用SMSサービス
- セキュリティイベント監視サービス
```

### 依存関係管理

1. **依存関係の特定**: 必要なすべてのコンポーネントをリスト化
2. **影響評価**: 依存関係が実装にどう影響するか理解
3. **統合計画**: 依存関係をどう統合するか定義
4. **インターフェース文書化**: 統合ポイントと契約を指定
5. **変更監視**: 依存関係の更新と互換性を追跡

## リスク評価

### よくあるリスクカテゴリ

**技術的リスク**:

- 実装の複雑さ
- パフォーマンスのボトルネック
- セキュリティ脆弱性
- 統合の課題

**ビジネスリスク**:

- 要件の変更
- タイムラインの制約
- リソースの可用性
- ユーザー採用

**運用リスク**:

- デプロイの課題
- 監視のギャップ
- メンテナンスのオーバーヘッド
- スケーラビリティの問題

### リスク評価テンプレート

```markdown
## リスク評価

### 高リスク
| リスク | 影響 | 確率 | 緩和策 |
|--------|------|------|--------|
| トークンセキュリティ実装 | 高 | 中 | 確立されたライブラリ使用、セキュリティレビュー |
| 負荷時のパフォーマンス | 中 | 高 | ロードテスト、キャッシング戦略 |

### 中リスク
| リスク | 影響 | 確率 | 緩和策 |
|--------|------|------|--------|
| メールサービスの信頼性 | 中 | 中 | 複数プロバイダー、フォールバックメカニズム |
| データベーススキーマ変更 | 低 | 高 | マイグレーション戦略、後方互換性 |

### 低リスク
| リスク | 影響 | 確率 | 緩和策 |
|--------|------|------|--------|
| UI/UXデザインの一貫性 | 低 | 低 | デザインシステム、コンポーネントライブラリ |
```

## SPECレビュープロセス

### レビューチェックリスト

**コンテンツレビュー**:

- [ ] 要件が明確で曖昧さなし
- [ ] すべてのユースケースがカバーされている
- [ ] エラー条件が指定されている
- [ ] 受け入れ基準がテスト可能
- [ ] 依存関係が特定されている

**形式レビュー**:

- [ ] YAMLフロントマターが完全で有効
- [ ] EARSパターンが正しく使用されている
- [ ] 言語が一貫している
- [ ] 構造がテンプレートに従っている
- [ ] TAG参照が正しい

**品質レビュー**:

- [ ] 技術的実現可能性が確認されている
- [ ] セキュリティ考慮事項が対処されている
- [ ] パフォーマンス要件が現実的
- [ ] 統合ポイントが定義されている
- [ ] リスク評価が完了している

### レビューワークフロー

1. **著者レビュー**: 完全性の自己レビュー
2. **ピアレビュー**: チームメンバーによる技術レビュー
3. **専門家レビュー**: ドメイン専門家の検証
4. **利害関係者レビュー**: ビジネス要件の検証
5. **最終承認**: 実装のための署名

## ツールとテンプレート

### SPECテンプレート

MoAI-ADKは異なるタイプの仕様のためのテンプレートを提供:

```markdown
# APIエンドポイントテンプレート
# @SPEC:EX-API-001: [機能名]

## 概要
APIエンドポイント機能の簡単な説明。

## EARS要件
- システムは[HTTPメソッド] [エンドポイントパス]を提供すべきである
- WHEN [リクエスト条件]、システムは[レスポンス]すべきである
- WHILE [状態条件]、システムは[動作]すべきである

## 技術要件
- リクエスト形式: [JSONスキーマ]
- レスポンス形式: [JSONスキーマ]
- ステータスコード: [期待されるコードのリスト]
- 認証: [要件]
- レート制限: [制限]

## 受け入れ基準
- [ ] エンドポイントが有効なリクエストを受け入れる
- [ ] 無効なリクエストの適切なエラーハンドリング
- [ ] レスポンス形式が仕様に一致
- [ ] 認証要件が強制されている
```

### 検証ツール

**組み込み検証**:

```bash
# SPEC構文と構造の検証
moai-adk validate-spec .moai/specs/SPEC-AUTH-001/spec.md

# よくある問題をチェック
moai-adk lint-specs .moai/specs/

# SPEC統計を生成
moai-adk spec-stats
```

**Alfredとの統合**:

```bash
# Alfred自動的にSPEC作成時に検証
/alfred:1-plan "機能説明"

# 実装前にSPEC品質をチェック
/alfred:validate-spec AUTH-001
```

## ベストプラクティス要約

### SPECの記述

1. **ユーザー価値から始める**: ユーザーが達成する必要があることに焦点
2. **具体的に**: 正確な言語を使用し、曖昧さを避ける
3. **シナリオで考える**: すべての可能なユースケースとエッジケースを検討
4. **成功を定義**: テスト可能な明確な受け入れ基準
5. **制約を考慮**: 技術的およびビジネス上の制限を特定

### SPECの管理

1. **バージョン管理**: セマンティックバージョニングで変更を追跡
2. **定期的なレビュー**: 要件が進化してもSPECを更新し続ける
3. **すべてをリンク**: TAGシステムで追跡可能性を維持
4. **決定を文書化**: なぜその決定がなされたかを記録
5. **進化のための計画**: 将来の変更と拡張のための設計

### チーム協業

1. **共有理解**: 要件についてチームの一致を確保
2. **早期フィードバック**: 実装が始まる前に意見を得る
3. **継続的な改善**: 理解が深まるにつれてSPECを更新
4. **知識共有**: SPECを学習文書として使用
5. **品質基準**: すべてのSPECで高い基準を維持

よく書かれたSPECはプロジェクト成功への投資であることを覚えておいてください。誤解を防ぎ、手戻りを削減し、全員が同じものを作っていることを保証します! 🎯
