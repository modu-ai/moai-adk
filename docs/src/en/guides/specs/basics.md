______________________________________________________________________

## title: SPEC基本ガイド description: MoAI-ADKの仕様書作成と管理の基本原則 lang: ja

# SPEC基本ガイド

SPEC（仕様書）はMoAI-ADK開発の核心要素で、明確な要件定義から高品質なコード実装までのすべてを導きます。

## SPECとは？

SPECは**単なるドキュメントではなく、実行可能な開発計画**です。EARS（Easy Approach to Requirements
Syntax）形式で書かれ、チームとAIが共に理解できる明確な要件を定義します。

### SPECの核心価値

1. **明確性**: あいまいさを排除し、すべての人が同じ理解を持つ
2. **追跡可能性**: @TAGシステムで要件からコードまで完全追跡
3. **テスト可能性**: 各要件が具体的なテストケースに変換可能
4. **協業**: チームとAIの共通言語として機能

## EARS文法の基本

### 5つの基本パターン

#### 1. Ubiquitous（基本的機能）

**形式**: 「システムは〜すべきである」 **用途**: システムの基本機能を記述

**例**:

```
- システムはユーザー認証を提供すべきである
- システムはデータ永続化機能をサポートすべきである
- システムはREST APIインターフェースを公開すべきである
```

#### 2. Event-driven（条件付き）

**形式**: 「WHEN 〜が起きたら、システムは〜すべきである」 **用途**: トリガーに基づく動作を記述

**例**:

```
- WHEN 有効な認証情報が提供されたら、システムはJWTトークンを発行すべきである
- WHEN ユーザーが登録フォームを送信したら、システムはアカウントを作成すべきである
- WHEN 在庫がゼロになったら、システムは在庫切れアラートを送信すべきである
```

#### 3. State-driven（状態中心）

**形式**: 「WHILE 〜状態である時、システムは〜すべきである」 **用途**: 状態に基づく継続的な動作を記述

**例**:

```
- WHILE ユーザーが認証されている時、システムは保護されたリソースへのアクセスを許可すべきである
- WHILE システムがメンテナンスモードである時、システムはメンテナンスページを表示すべきである
- WHILE ユーザーセッションが有効である時、システムはユーザーデータをキャッシュすべきである
```

#### 4. Optional（選択的）

**形式**: 「WHERE 〜がある場合、システムは〜できる」 **用途**: オプション機能や条件付き機能を記述

**例**:

```
- WHERE リフレッシュトークンが有効な場合、システムは新しいアクセストークンを発行できる
- WHERE ユーザープロフィール画像がアップロードされた場合、システムは画像を自動圧縮できる
- WHERE 管理者権限がある場合、システムはシステム設定を変更できる
```

#### 5. Constraints（制約）

**形式**: 「〜は〜を超えてはならない」 **用途**: 制約事項と禁止事項を記述

**例**:

```
- パスワードは8文字未満であってはならない
- APIレスポンスタイムは2000msを超えてはならない
- ユーザー名は特殊文字を含んでいてはならない
- 1回のリクエストで処理できるデータは1000件を超えてはならない
```

## SPEC構造

### 基本構成

```yaml
---
# YAML Frontmatter
id: SPEC-ID
version: 0.1.0
status: draft
priority: high
created: 2025-01-06
updated: 2025-01-06
author: @username
tags: [authentication, security, api]
dependencies: []
---

# @SPEC:EX-SPEC-ID: タイトル

## 要件
### EARS形式の要件記述
- Ubiquitous Requirements
- Event-driven Requirements
- State-driven Requirements
- Optional Features
- Constraints

## 実装計画
### 技術選定
### アーキテクチャ設計
### リスク要因
### 解決戦略

## 受諾基準
### 機能要件
### 非機能要件
### テストケース

## 履歴
### 変更履歴
### バージョン管理
```

### 詳細例

```yaml
---
id: AUTH-001
version: 0.2.0
status: in_progress
priority: critical
created: 2025-01-06
updated: 2025-01-06
author: @developer
tags: [authentication, security, jwt, api]
dependencies: [USER-001, SEC-001]
---

# @SPEC:EX-AUTH-001: ユーザー認証システム

## 要件

### Ubiquitous Requirements
- システムはJWTベースの認証システムを提供すべきである
- システムはユーザー登録機能をサポートすべきである
- システムはパスワードリセット機能を提供すべきである

### Event-driven Requirements
- WHEN 有効なメールアドレスとパスワードが提供されたら、システムはJWTアクセストークンを発行すべきである
- WHEN 無効な認証情報が提供されたら、システムは401ステータスコードとエラーメッセージを返すべきである
- WHEN アクセストークンが期限切れになったら、システムは401ステータスコードを返すべきである
- WHEN ユーザーが登録を完了したら、システムは確認メールを送信すべきである

### State-driven Requirements
- WHILE ユーザーが認証されている時、システムは保護されたAPIエンドポイントへのアクセスを許可すべきである
- WHILE ユーザーが未認証である時、システムは公開エンドポイントのみへのアクセスを制限すべきである
- WHILE アカウントがロックされている時、システムはすべての認証試行を拒否すべきである

### Optional Features
- WHERE リフレッシュトークンが有効な場合、システムは新しいアクセストークンを発行できる
- WHERE 二要素認証が有効な場合、システムはTOTPコードを要求できる
- WHERE ソーシャルログインが設定されている場合、システムは外部プロバイダ経由で認証できる

### Constraints
- パスワードは最低8文字でなければならない
- パスワードは大文字、小文字、数字、特殊文字を各1文字以上含まなければならない
- アクセストークンの有効期限は15分を超えてはならない
- リフレッシュトークンの有効期限は30日を超えてはならない
- ログイン試行失敗は5回连续であってはならない
- アカウントロック時間は30分未満であってはならない

## 実装計画

### 技術選定
- **認証フレームワーク**: Passlib (パスワードハッシュ)
- **JWTライブラリ**: PyJWT (トークン生成・検証)
- **データベース**: PostgreSQL (ユーザーデータ)
- **キャッシュ**: Redis (セッション管理)
- **二要素認証**: PyOTP (TOTP生成)

### アーキテクチャ設計
```

src/auth/ ├── models.py # @CODE:EX-AUTH-001:MODEL ├── services.py # @CODE:EX-AUTH-001:SERVICE ├──
api.py # @CODE:EX-AUTH-001:API ├── middleware.py # @CODE:EX-AUTH-001:MIDDLEWARE └── utils.py #
@CODE:EX-AUTH-001:UTILS

tests/auth/ ├── test_models.py # @TEST:EX-AUTH-001 ├── test_services.py # @TEST:EX-AUTH-002 ├──
test_api.py # @TEST:EX-AUTH-003 └── test_middleware.py # @TEST:EX-AUTH-004

```

### リスク要因
1. **セキュリティ脆弱性**: JWT実装の誤り
2. **パフォーマンス**: 大量同時認証リクエスト
3. **スケーラビリティ**: トークンストレージの容量
4. **互換性**: クライアント側の古いトークン処理

### 解決戦略
1. **セキュリティ**: 業界標準ライブラリ使用、定期的なセキュリティ監査
2. **パフォーマンス**: Redisキャッシュ、レート制限
3. **スケーラビリティ**: 分散ストレージ、トークン分割戦略
4. **互換性**: バージョニング、段階的移行戦略

## 受諾基準

### 機能要件
- [ ] 有効な認証情報でログインできる
- [ ] 無効な認証情報で401エラーが返る
- [ ] アクセストークン有効期限が15分である
- [ ] リフレッシュトークンで新しいアクセストークン取得できる
- [ ] ユーザー登録が正常に完了する
- [ ] パスワードリセットメールが送信される
- [ ] 二要素認証が有効に機能する

### 非機能要件
- [ ] レスポンスタイムが500ms以内
- [ ] 1000同時リクエストを処理できる
- [ ] すべてのパスワードが適切にハッシュ化される
- [ ] トークンが改ざんされていないことを検証できる
- [ ] ログイン試行失敗回数が制限される
- [ ] アカウントロック機能が正常に動作する

### テストケース
1. **正常ログイン**: 有効な認証情報で200レスポンス
2. **無効認証**: 無効な認証情報で401レスポンス
3. **トークン有効期限**: 期限切れトークンで401レスポンス
4. **リフレッシュトークン**: 有効なリフレッシュトークンで新しいアクセストークン発行
5. **パスワードポリシー**: 弱いパスワードで422レスポンス
6. **レート制限**: 過度なログイン試行で429レスポンス
7. **アカウントロック**: 5回失敗後アカウントがロックされる

## 履歴

### 変更履歴
- **v0.2.0** (2025-01-06): 二要素認証機能追加、リフレッシュトークン有効期限変更
- **v0.1.1** (2025-01-05): パスワードポリシー強化、アカウントロック機能追加
- **v0.1.0** (2025-01-04): 初期バージョン、基本認証機能

### バージョン管理
- **メジャーバージョン**: 後方互換性のない変更
- **マイナーバージョン**: 後方互換性のある機能追加
- **パッチバージョン**: バグ修正
```

## SPEC作成プロセス

### ステップ1: 要件収集

1. **ステークホルダーインタビュー**: ビジネス要件を収集
2. **技術的制約分析**: 実装上の制約を特定
3. **ユースケース分析**: ユーザーシナリオを定義
4. **競合分析**: 類似システムの機能を調査

### ステップ2: EARS形式での記述

1. **Ubiquitous Requirementsから開始**: 基本機能を定義
2. **Event-driven Requirements追加**: トリガー動作を記述
3. **State-driven Requirements記述**: 状態ベースの動作を定義
4. **Optional Features検討**: オプション機能を追加
5. **Constraints定義**: 制約事項を明確化

### ステップ3: 実装計画作成

1. **技術選定**: 適切な技術スタックを選択
2. **アーキテクチャ設計**: システム構造を設計
3. **リスク分析**: 潜在的リスクを特定
4. **解決戦略立案**: リスク対応策を計画

### ステップ4: 受諾基準定義

1. **機能要件**: 必須機能をリスト化
2. **非機能要件**: 品質要件を定義
3. **テストケース**: 具体的なテストシナリオ作成
4. **検証基準**: 完了条件を明確化

### ステップ5: レビューと承認

1. **チームレビュー**: 技術的実現可能性を検証
2. **ステークホルダー承認**: ビジネス要件との一致を確認
3. **品質チェック**: SPECの完全性と一貫性を検証
4. **承認**: 実装開始の最終承認

## SPEC品質基準

### 1. 明確性 (Clarity)

**良い例**:

```
- WHEN ユーザーが有効な認証情報を提供したら、システムはJWTアクセストークンを発行すべきである
```

**悪い例**:

```
- ユーザー認証機能
- ログイン処理
```

### 2. 完全性 (Completeness)

- ✅ すべての機能要件が含まれている
- ✅ エラーケースが考慮されている
- ✅ 制約事項が明記されている
- ✅ 境界条件が定義されている

### 3. 一貫性 (Consistency)

- ✅ 用語が一貫して使用されている
- ✅ 命名規則が統一されている
- ✅ 構造が標準化されている
- ✅ 形式が統一されている

### 4. 検証可能性 (Verifiability)

- ✅ 各要件がテスト可能
- ✅ 成功基準が明確
- ✅ 失敗条件が定義されている
- ✅ 測定可能な指標がある

### 5. 追跡可能性 (Traceability)

- ✅ @TAGで他の成果物と連結
- ✅ 変更履歴が記録されている
- ✅ 依存関係が明記されている
- ✅ バージョン管理がされている

## SPEC管理のベストプラクティス

### 1. 適切な粒度

- **一つのSPEC**: 一つの機能または密接に関連する機能群
- **原子性**: 分割できない最小単位
- **独立性**: 他のSPECへの過度な依存を避ける

### 2. バージョン管理

```yaml
# セマンティックバージョニング
version: 1.2.3

# 1: メジャーバージョン - 後方互換性のない変更
# 2: マイナーバージョン - 後方互換性のある機能追加
# 3: パッチバージョン - バグ修正
```

### 3. 状態管理

```
planning → draft → in_progress → testing → completed → deprecated
```

### 4. 依存関係管理

```yaml
dependencies:
  - USER-001  # 必須依存
  - SEC-001   # 必須依存
  - UI-001    # オプション依存
```

## トラブルシューティング

### よくある問題

**要件が曖昧**:

- 具体的な数値や条件を追加
- 成功・失敗条件を明確化
- ユーザーストーリーを追加

**実現不可能な要件**:

- 技術的制約を再評価
- 代替案を検討
- 段階的実装を計画

**依存関係が複雑**:

- 依存関係グラフを作成
- 循環依存を解消
- 実装順序を最適化

## ツールとテンプレート

### SPEC作成支援ツール

```bash
# Alfred自動生成
/alfred:1-plan "機能説明"

# テンプレート使用
moai-adk spec template --type=api
moai-adk spec template --type=ui
moai-adk spec template --type=database
```

### 品質検証ツール

```bash
# SPEC品質検証
/alfred:3-sync --validate-specs

# EARS形式検証
/alfred:validate --ears-format

# 依存関係検証
/alfred:validate --dependencies
```

______________________________________________________________________

**📚 次のステップ**:

- [EARS詳細ガイド](ears.md)で要件記述技術
- [TAGシステム](tags.md)で追跡可能性管理
- [TDDガイド](../tdd/index.md)でテスト駆動実装
