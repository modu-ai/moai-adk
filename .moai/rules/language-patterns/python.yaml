# Python Language Patterns
# Common patterns for Python 3.13+ development
# Version: 1.0.0
# Last Updated: 2026-01-22

---
language: "python"
version: "3.13+"
description: "Common patterns for modern Python development"

# Language Features
features:
  jit_compiler:
    name: "JIT Compiler via PEP 744"
    description: "Experimental JIT compiler for performance improvements"
    enable: "PYTHON_JIT=1"
    build_option: "--enable-experimental-jit"
    use_case: "CPU-bound code performance improvements"

  gil_free_mode:
    name: "GIL-Free Mode via PEP 703"
    description: "Experimental free-threaded Python build"
    build: "python3.13t"
    use_case: "CPU-intensive multi-threaded applications"
    warning: "Not recommended for production use yet"

  pattern_matching:
    name: "Pattern Matching with match and case"
    syntax: "match and case statements"
    example: |
      def process_response(response):
          match response:
              case {"status": "ok", "data": data}:
                  return f"Success: {data}"
              case {"status": "error", "message": msg}:
                  return f"Error: {msg}"
              case {"status": status} if status in ("pending", "processing"):
                  return "In progress..."
              case _:
              return "Unknown response"

# Web Framework Patterns
web_frameworks:
  fastapi:
    name: "FastAPI 0.115+"
    patterns:
      async_dependency_injection:
        description: "Async dependency injection pattern"
        example: |
          from fastapi import FastAPI, Depends
          from sqlalchemy.ext.asyncio import AsyncSession
          from contextlib import asynccontextmanager

          @asynccontextmanager
          async def lifespan(app: FastAPI):
              await init_db()
              yield
              await cleanup()

          app = FastAPI(lifespan=lifespan)

          async def get_db() -> AsyncGenerator[AsyncSession, None]:
              async with async_session() as session:
                  yield session

          @app.get("/users/{user_id}")
          async def get_user(user_id: int, db: AsyncSession = Depends(get_db)):
              user = await get_user_by_id(db, user_id)
              return UserResponse.model_validate(user)

      class_based_dependencies:
        description: "Class-based dependency pattern"
        example: |
          from fastapi import Depends

          class Paginator:
              def __init__(self, page: int = 1, size: int = 20):
                  self.page = max(1, page)
                  self.size = min(100, max(1, size))
                  self.offset = (self.page - 1) * self.size

          @app.get("/items")
          async def list_items(paginator: Paginator = Depends()):
              return get_page(paginator.offset, paginator.size)

  django:
    name: "Django 5.2 LTS"
    patterns:
      composite_primary_keys:
        description: "Composite primary key pattern"
        example: |
          from django.db import models

          class OrderItem(models.Model):
              order = models.ForeignKey(Order, on_delete=models.CASCADE)
              product = models.ForeignKey(Product, on_delete=models.CASCADE)
              quantity = models.IntegerField()

              class Meta:
                  pk = models.CompositePrimaryKey("order", "product")

      url_reverse_with_params:
        description: "URL reverse with query parameters"
        example: |
          from django.urls import reverse

          url = reverse(
              "search",
              query={"q": "django", "page": 1},
              fragment="results"
          )

# Data Validation Patterns
data_validation:
  pydantic:
    name: "Pydantic v2.9"
    patterns:
      reusable_validators:
        description: "Reusable validators with Annotated"
        example: |
          from typing import Annotated
          from pydantic import AfterValidator, BaseModel

          def validate_positive(v: int) -> int:
              if v <= 0:
                  raise ValueError("must be positive")
              return v

          PositiveInt = Annotated[int, AfterValidator(validate_positive)]

          class Product(BaseModel):
              price: PositiveInt
              quantity: PositiveInt

      model_validator:
        description: "Cross-field validation with model_validator"
        example: |
          from pydantic import BaseModel, model_validator
          from typing import Self

          class DateRange(BaseModel):
              start_date: date
              end_date: date

              @model_validator(mode="after")
              def validate_dates(self) -> Self:
                  if self.end_date < self.start_date:
                      raise ValueError("end_date must be after start_date")
                  return self

      config_dict:
        description: "ConfigDict best practices"
        example: |
          from pydantic import BaseModel, ConfigDict

          class BaseSchema(BaseModel):
              model_config = ConfigDict(
                  from_attributes=True,
                  populate_by_name=True,
                  extra="forbid",
                  str_strip_whitespace=True
              )

# Database Patterns
database:
  sqlalchemy:
    name: "SQLAlchemy 2.0 Async"
    patterns:
      engine_setup:
        description: "Async engine and session setup"
        example: |
          from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

          engine = create_async_engine(
              "postgresql+asyncpg://user:pass@localhost/db",
              pool_pre_ping=True,
              echo=True
          )

          async_session = async_sessionmaker(
              engine,
              class_=AsyncSession,
              expire_on_commit=False
          )

      repository_pattern:
        description: "Repository pattern for database operations"
        example: |
          class UserRepository:
              def __init__(self, session: AsyncSession):
                  self.session = session

              async def get_by_id(self, user_id: int) -> User | None:
                  result = await self.session.execute(
                      select(User).where(User.id == user_id)
                  )
                  return result.scalar_one_or_none()

              async def create(self, data: UserCreate) -> User:
                  user = User(**data.model_dump())
                  self.session.add(user)
                  await self.session.commit()
                  await self.session.refresh(user)
                  return user

      streaming_results:
        description: "Streaming large result sets"
        example: |
          async def stream_users(db: AsyncSession):
              async for user in (await db.stream(select(User))).scalars():
                  yield user

# Testing Patterns
testing:
  pytest:
    name: "pytest with pytest-asyncio"
    patterns:
      async_fixtures:
        description: "Async fixtures with pytest-asyncio"
        example: |
          import pytest
          import pytest_asyncio
          from httpx import AsyncClient

          @pytest_asyncio.fixture
          async def async_client(app):
              async with AsyncClient(app=app, base_url="http://test") as client:
                  yield client

          @pytest_asyncio.fixture
          async def db_session(async_session):
              async with async_session.begin():
                  yield async_session
              await async_session.rollback()

      parametrized_tests:
        description: "Parametrized test cases"
        example: |
          @pytest.mark.parametrize(
              "input_data,expected_status",
              [
                  ({"name": "Test", "email": "test@example.com"}, 201),
                  ({"name": "", "email": "test@example.com"}, 422),
              ],
              ids=["valid", "empty_name"]
          )
          async def test_create_user(async_client, input_data, expected_status):
              response = await async_client.post("/users", json=input_data)
              assert response.status_code == expected_status

      fixture_factories:
        description: "Fixture factory pattern"
        example: |
          @pytest.fixture
          def user_factory():
              async def factory(db: AsyncSession, **kwargs):
              defaults = {"name": "Test", "email": "test@example.com"}
              user = User(**{**defaults, **kwargs})
              db.add(user)
              await db.commit()
              return user
          return factory

# Type Hints Patterns
type_hints:
  protocol:
    name: "Protocol for structural typing"
    description: "Structural typing with Protocol"
    example: |
      from typing import Protocol, runtime_checkable, TypeVar

      T = TypeVar("T")

      @runtime_checkable
      class Repository(Protocol[T]):
          async def get(self, id: int) -> T | None: ...
          async def create(self, data: dict) -> T: ...
          async def delete(self, id: int) -> bool: ...

  paramspec:
    name: "ParamSpec for decorators"
    description: "Decorator pattern with ParamSpec"
    example: |
      from typing import ParamSpec, TypeVar, Callable
      from functools import wraps

      P = ParamSpec("P")
      R = TypeVar("R")

      def retry(times: int = 3):
          def decorator(func: Callable[P, R]) -> Callable[P, R]:
              @wraps(func)
              async def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
                  for attempt in range(times):
                      try:
                          return await func(*args, **kwargs)
                      except Exception:
                          if attempt == times - 1:
                              raise
              return wrapper
          return decorator

# Package Management
package_management:
  poetry:
    name: "Poetry with pyproject.toml"
    example: |
      [tool.poetry]
      name = "myproject"
      version = "0.1.0"
      python = "^3.13"

      [tool.poetry.dependencies]
      fastapi = "^0.115.0"
      pydantic = "^2.9.0"
      sqlalchemy = {extras = ["asyncio"], version = "^2.0.0"}

      [tool.poetry.dev-dependencies]
      pytest = "^8.0.0"
      pytest-asyncio = "^0.24.0"
      ruff = "^0.8.0"

      [tool.ruff]
      line-length = 88
      target-version = "py313"

      [tool.pytest.ini_options]
      asyncio_mode = "auto"

  uv:
    name: "uv fast package manager"
    commands:
      install: "curl -LsSf https://astral.sh/uv/install.sh | sh"
      venv: "uv venv"
      install_deps: "uv pip install -r requirements.txt"
      add: "uv add package-name"

# Best Practices
best_practices:
  code_style:
    - "Use ruff for linting (faster than flake8)"
    - "Use black for code formatting"
    - "Use isort for import sorting"
    - "Use mypy for type checking"

  async_patterns:
    - "Prefer async/await over callbacks"
    - "Use AsyncSession for database operations"
    - "Use AsyncClient for HTTP requests"
    - "Avoid blocking operations in async functions"

  testing:
    - "Use pytest-asyncio for async tests"
    - "Use fixtures for test setup"
    - "Parametrize for multiple test cases"
    - "Aim for 85%+ coverage"
