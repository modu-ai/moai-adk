# TypeScript Language Patterns
# Common patterns for TypeScript 5.9+ development
# Version: 1.0.0
# Last Updated: 2026-01-22

---
language: "typescript"
version: "5.9+"
description: "Common patterns for modern TypeScript development"

# Language Features
features:
  satisfies_operator:
    name: "satisfies Operator for Type Checking"
    description: "Type checking without widening"
    example: |
      type Colors = "red" | "green" | "blue";

      const palette = {
          red: [255, 0, 0],
          green: "#00ff00",
          blue: [0, 0, 255]
      } satisfies Record<Colors, string | number[]>;

      // palette.red is number[], can use map()
      // palette.green is string, can use toUpperCase()

  deferred_modules:
    name: "Deferred Module Evaluation"
    description: "Load modules on first use"
    example: |
      import * as namespace from "./heavy-module.js" defer;

      function processData() {
          // Module loads here on first access
          return namespace.process();
      }

  modern_decorators:
    name: "Modern Decorators Stage 3"
    description: "Decorator pattern for methods"
    example: |
      function logged(
          target: Function,
          context: ClassMethodDecoratorContext
      ) {
          return function (this: any, ...args: any[]) {
              console.log(`Calling ${context.name}`);
              return target.apply(this, args);
          };
      }

      class DataService {
          @logged
          async fetchData() {
              return { data: "value" };
          }
      }

# React Patterns
react:
  version: "19"
  patterns:
    server_components:
      description: "Server Components default in App Router"
      example: |
        // app/users/[id]/page.tsx
        interface PageProps {
          params: Promise<{ id: string }>;
        }

        export default async function Page({ params }: PageProps) {
          const { id } = await params;
          const user = await db.users.findById(id);

          if (!user) {
              notFound();
          }

          return <main>{user.name}</main>;
        }

    use_hook:
      description: "use hook for unwrapping Promises"
      example: |
        "use client";

        import { use } from "react";

        interface UserProfileProps {
          userPromise: Promise<User>;
        }

        export function UserProfile({ userPromise }: UserProfileProps) {
          const user = use(userPromise);
          return <div>{user.name}</div>;
        }

    actions:
      description: "Actions for form handling with server functions"
      example: |
        "use server";

        import { revalidatePath } from "next/cache";
        import { z } from "zod";

        const CreateUserSchema = z.object({
          name: z.string().min(2),
          email: z.string().email()
        });

        export async function createUser(formData: FormData) {
          const data = CreateUserSchema.parse(
              Object.fromEntries(formData)
          );

          await db.users.create(data);
          revalidatePath("/users");
        }

    use_action_state:
      description: "useActionState for form status"
      example: |
        "use client";

        import { useActionState } from "react";

        export function CreateUserForm() {
          const [state, action, isPending] =
              useActionState(createUser, null);

          return (
              <form action={action}>
                  <input
                      name="name"
                      disabled={isPending}
                  />
                  <button disabled={isPending}>
                      {isPending ? "Creating..." : "Create"}
                  </button>
                  {state?.error && (
                      <p>{state.error}</p>
                  )}
              </form>
          );
        }

# Next.js Patterns
nextjs:
  version: "16"
  router: "App Router"
  patterns:
    route_structure:
      description: "App Router directory structure"
      example: |
        app/
        ├── layout.tsx          # Root layout
        ├── page.tsx            # Home route
        ├── loading.tsx         # Loading UI
        ├── error.tsx           # Error boundary
        ├── api/
        │   └── route.ts        # API route
        └── users/
            ├── page.tsx        # /users
            └── [id]/
                └── page.tsx    # /users/:id

    metadata_api:
      description: "Metadata API for SEO"
      example: |
        import type { Metadata } from "next";

        export const metadata: Metadata = {
          title: {
              default: "My App",
              template: "%s | My App"
          },
          description: "Description here"
        };

        export async function generateMetadata(
          { params }: { params: Promise<{ id: string }> }
        ): Promise<Metadata> {
          const { id } = await params;
          const user = await getUser(id);

          return {
              title: user.name
          };
        }

    server_actions:
      description: "Server actions with validation"
      example: |
        "use server";

        import { z } from "zod";
        import { revalidatePath, redirect } from "next/navigation";

        const UpdateUserSchema = z.object({
          id: z.string().uuid(),
          name: z.string().min(2),
          email: z.string().email()
        });

        export async function updateUser(
          prevState: any,
          formData: FormData
        ) {
          const data = UpdateUserSchema.safeParse(
              Object.fromEntries(formData)
          );

          if (!data.success) {
              return { errors: data.error.flatten() };
          }

          await db.users.update(data.data);
          revalidatePath("/users");
          redirect("/users");
        }

# tRPC Patterns
trpc:
  description: "Type-safe APIs with tRPC"
  patterns:
    server_setup:
      description: "tRPC server initialization"
      example: |
        import { initTRPC, TRPCError } from "@trpc/server";
        import { z } from "zod";

        const t = initTRPC.context<Context>().create();

        export const router = t.router;
        export const publicProcedure = t.procedure;
        export const protectedProcedure = t.procedure
          .use(({ ctx, next }) => {
              if (!ctx.user) {
                  throw new TRPCError({
                      code: "UNAUTHORIZED"
                  });
              }
              return next({ ctx: { ...ctx, user: ctx.user } });
          });

    router_definition:
      description: "Router definition with procedures"
      example: |
        import { z } from "zod";
        import { router, publicProcedure } from "./trpc";

        export const userRouter = router({
          getById: publicProcedure
              .input(z.object({ id: z.string().uuid() }))
              .query(({ input }) => {
                  return db.users.findById(input.id);
              }),

          create: protectedProcedure
              .input(z.object({
                  name: z.string().min(2),
                  email: z.string().email()
              }))
              .mutation(({ input }) => {
                  return db.users.create(input);
              })
        });

    client_usage:
      description: "Client-side tRPC usage"
      example: |
        "use client";

        import { trpc } from "./trpc";

        export function UserList() {
          const { data, isLoading } =
              trpc.user.list.useQuery({ page: 1 });

          const createMutation =
              trpc.user.create.useMutation();

          if (isLoading) return <div>Loading...</div>;

          return (
              <ul>
                  {data?.users.map(user => (
                      <li key={user.id}>{user.name}</li>
                  ))}
              </ul>
          );
        }

# Zod Schema Patterns
zod:
  name: "Zod Schema Validation"
  patterns:
    complex_validation:
      description: "Complex validation with refinements"
      example: |
        import { z } from "zod";

        export const UserSchema = z.object({
          id: z.string().uuid(),
          name: z.string().min(2).max(100),
          email: z.string().email(),
          role: z.enum(["admin", "user", "guest"]),
          createdAt: z.coerce.date()
        }).strict();

        export type User = z.infer<typeof UserSchema>;

        export const CreateUserSchema =
            UserSchema.omit(["id", "createdAt"])
                .extend({
                  password: z.string().min(8),
                  confirmPassword: z.string()
                })
                .refine(
                  (data) => data.password === data.confirmPassword,
                  {
                      message: "Passwords don't match",
                      path: ["confirmPassword"]
                  }
                );

# State Management Patterns
state_management:
  zustand:
    description: "Zustand for client state"
    example: |
      import { create } from "zustand";
      import { devtools, persist } from "zustand/middleware";

      interface AuthState {
          user: User | null;
          login: (user: User) => void;
          logout: () => void;
      }

      export const useAuthStore = create<AuthState>()(
          devtools(
              persist(
                  (set) => ({
                      user: null,
                      login: (user) => set({ user }),
                      logout: () => set({ user: null })
                  }),
                  { name: "auth-storage" }
              )
          )
      );

  jotai:
    description: "Jotai for atomic state"
    example: |
      import { atom } from "jotai";
      import { atomWithStorage } from "jotai/utils";

      export const countAtom = atom(0);

      export const doubleCountAtom = atom((get) =>
          get(countAtom) * 2
      );

      export const themeAtom = atomWithStorage<"light" | "dark">(
          "theme",
          "light"
      );

# Best Practices
best_practices:
  type_safety:
    - "Use zod for runtime validation"
    - "Infer types from schemas"
    - "Avoid 'any' type"
    - "Use strict mode in tsconfig"

  react_patterns:
    - "Prefer Server Components when possible"
    - "Use 'use' for Promises in Client Components"
    - "Implement proper loading states"
    - "Handle errors with error boundaries"

  nextjs_patterns:
    - "Use App Router over Pages Router"
    - "Implement Server Actions for mutations"
    - "Use dynamic imports for code splitting"
    - "Optimize images with next/image"
