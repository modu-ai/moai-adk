# Flutter Language Patterns
# Common patterns for Flutter 3.24+ / Dart 3.5+ development
# Version: 1.0.0
# Last Updated: 2026-01-23

---
language: "flutter"
version: "3.24+ / Dart 3.5+"
description: "Common patterns for modern Flutter development"

# Dart Language Features
dart_features:
  records:
    name: "Records"
    description: "Lightweight data structures"
    example: |
      (String, int) parseUser(String input) {
        final parts = input.split(':');
        return (parts[0], int.parse(parts[1]));
      }

      final (name, age) = parseUser('John:25');

  patterns:
    name: "Pattern Matching"
    description: "Destructuring and matching"
    example: |
      String describeUser(User user) => switch (user) {
        User(role: 'admin', active: true) => 'Active Admin',
        User(role: 'admin') => 'Inactive Admin',
        User(active: true) => 'Active User',
        _ => 'Inactive User',
      };

  sealed_classes:
    name: "Sealed Classes"
    description: "Exhaustive pattern matching"
    example: |
      sealed class AuthState {}
      class Unauthenticated extends AuthState {}
      class Authenticated extends AuthState {
        final User user;
        Authenticated(this.user);
      }
      class Loading extends AuthState {}

      Widget buildAuth(AuthState state) => switch (state) {
        Unauthenticated() => LoginPage(),
        Authenticated(:final user) => HomePage(user: user),
        Loading() => LoadingSpinner(),
      };

# State Management
state_management:
  riverpod:
    name: "Riverpod"
    description: "Modern state management"
    example: |
      @riverpod
      class UserNotifier extends _$UserNotifier {
        @override
        FutureOr<User?> build() async {
          return ref.watch(authRepositoryProvider).currentUser;
        }

        Future<void> updateProfile(UserProfile profile) async {
          state = const AsyncLoading();
          state = await AsyncValue.guard(() async {
            final user = await ref.read(userRepositoryProvider)
                .updateProfile(profile);
            return user;
          });
        }
      }

      // Usage in widget
      class ProfilePage extends ConsumerWidget {
        @override
        Widget build(BuildContext context, WidgetRef ref) {
          final userAsync = ref.watch(userNotifierProvider);
          return userAsync.when(
            data: (user) => ProfileView(user: user),
            loading: () => const CircularProgressIndicator(),
            error: (e, st) => ErrorView(error: e),
          );
        }
      }

# Navigation
navigation:
  go_router:
    name: "go_router"
    description: "Declarative routing"
    example: |
      final router = GoRouter(
        routes: [
          GoRoute(
            path: '/',
            builder: (context, state) => const HomePage(),
            routes: [
              GoRoute(
                path: 'users/:id',
                builder: (context, state) {
                  final id = state.pathParameters['id']!;
                  return UserDetailPage(userId: id);
                },
              ),
            ],
          ),
        ],
        redirect: (context, state) {
          final isLoggedIn = /* check auth */;
          if (!isLoggedIn && state.matchedLocation != '/login') {
            return '/login';
          }
          return null;
        },
      );

# Widget Patterns
widgets:
  composition:
    description: "Widget composition pattern"
    example: |
      class UserCard extends StatelessWidget {
        const UserCard({
          super.key,
          required this.user,
          this.onTap,
        });

        final User user;
        final VoidCallback? onTap;

        @override
        Widget build(BuildContext context) {
          return Card(
            child: ListTile(
              leading: CircleAvatar(
                backgroundImage: NetworkImage(user.avatarUrl),
              ),
              title: Text(user.name),
              subtitle: Text(user.email),
              onTap: onTap,
            ),
          );
        }
      }

  hooks:
    name: "Flutter Hooks"
    description: "Reusable stateful logic"
    example: |
      class SearchPage extends HookConsumerWidget {
        @override
        Widget build(BuildContext context, WidgetRef ref) {
          final searchController = useTextEditingController();
          final debouncer = useDebouncer(duration: Duration(milliseconds: 300));

          useEffect(() {
            void listener() {
              debouncer.run(() {
                ref.read(searchProvider.notifier).search(searchController.text);
              });
            }
            searchController.addListener(listener);
            return () => searchController.removeListener(listener);
          }, []);

          return TextField(controller: searchController);
        }
      }

# Testing Patterns
testing:
  widget_tests:
    description: "Widget testing pattern"
    example: |
      void main() {
        testWidgets('UserCard displays user info', (tester) async {
          final user = User(name: 'John', email: 'john@example.com');

          await tester.pumpWidget(
            MaterialApp(
              home: UserCard(user: user),
            ),
          );

          expect(find.text('John'), findsOneWidget);
          expect(find.text('john@example.com'), findsOneWidget);
        });

        testWidgets('UserCard handles tap', (tester) async {
          var tapped = false;
          final user = User(name: 'John', email: 'john@example.com');

          await tester.pumpWidget(
            MaterialApp(
              home: UserCard(user: user, onTap: () => tapped = true),
            ),
          );

          await tester.tap(find.byType(ListTile));
          expect(tapped, isTrue);
        });
      }

# Best Practices
best_practices:
  code_style:
    - "Use dart format for formatting"
    - "Use dart analyze for static analysis"
    - "Prefer const constructors"
    - "Use sealed classes for state"

  architecture:
    - "Use Riverpod for state management"
    - "Use go_router for navigation"
    - "Separate UI from business logic"
    - "Use repository pattern for data access"
