# Ruby Language Patterns
# Common patterns for Ruby 3.3+ development
# Version: 1.0.0
# Last Updated: 2026-01-23

---
language: "ruby"
version: "3.3+"
description: "Common patterns for modern Ruby development"

# Language Features
features:
  pattern_matching:
    name: "Pattern Matching"
    description: "Structural pattern matching"
    example: |
      def process_response(response)
        case response
        in { status: "ok", data: }
          "Success: #{data}"
        in { status: "error", message: }
          "Error: #{message}"
        in { status: "pending" | "processing" }
          "In progress..."
        else
          "Unknown response"
        end
      end

  ractors:
    name: "Ractors"
    description: "Parallel execution without GVL"
    example: |
      workers = 4.times.map do
        Ractor.new do
          loop do
            task = Ractor.receive
            result = process(task)
            Ractor.yield(result)
          end
        end
      end

      tasks.each { |task| workers.sample.send(task) }
      results = workers.map(&:take)

  data_classes:
    name: "Data Classes"
    description: "Immutable value objects"
    example: |
      User = Data.define(:id, :name, :email) do
        def greeting
          "Hello, #{name}!"
        end
      end

      user = User.new(id: 1, name: "Alice", email: "alice@example.com")
      updated = user.with(name: "Alice Smith")

# Web Framework Patterns
web_frameworks:
  rails:
    name: "Rails 7.2"
    patterns:
      active_record:
        description: "Modern Active Record patterns"
        example: |
          class User < ApplicationRecord
            has_many :posts, dependent: :destroy
            has_one :profile

            validates :email, presence: true, uniqueness: true
            validates :name, presence: true, length: { maximum: 100 }

            scope :active, -> { where(active: true) }
            scope :with_posts, -> { includes(:posts).where.not(posts: { id: nil }) }

            def full_name
              "#{first_name} #{last_name}"
            end
          end

      concerns:
        description: "Reusable concerns"
        example: |
          module Searchable
            extend ActiveSupport::Concern

            included do
              scope :search, ->(query) {
                where("name ILIKE ?", "%#{query}%")
              }
            end

            class_methods do
              def searchable_columns
                [:name, :email]
              end
            end
          end

      hotwire:
        description: "Hotwire/Turbo patterns"
        example: |
          # Controller
          def create
            @post = Post.new(post_params)
            if @post.save
              respond_to do |format|
                format.turbo_stream
                format.html { redirect_to @post }
              end
            else
              render :new, status: :unprocessable_entity
            end
          end

          # View: create.turbo_stream.erb
          <%= turbo_stream.prepend "posts", @post %>
          <%= turbo_stream.update "flash", partial: "shared/flash" %>

# Testing Patterns
testing:
  rspec:
    name: "RSpec"
    patterns:
      model_spec:
        description: "Model testing pattern"
        example: |
          RSpec.describe User, type: :model do
            describe "validations" do
              it { is_expected.to validate_presence_of(:email) }
              it { is_expected.to validate_uniqueness_of(:email) }
            end

            describe "associations" do
              it { is_expected.to have_many(:posts) }
            end

            describe "#full_name" do
              let(:user) { build(:user, first_name: "John", last_name: "Doe") }

              it "returns the full name" do
                expect(user.full_name).to eq("John Doe")
              end
            end
          end

      request_spec:
        description: "Request/integration testing"
        example: |
          RSpec.describe "Users API", type: :request do
            describe "GET /api/users/:id" do
              let(:user) { create(:user) }

              it "returns the user" do
                get api_user_path(user)

                expect(response).to have_http_status(:ok)
                expect(json_response[:id]).to eq(user.id)
              end
            end
          end

# Best Practices
best_practices:
  code_style:
    - "Use RuboCop for linting"
    - "Use frozen string literals"
    - "Prefer keyword arguments"
    - "Use Data classes for value objects"

  rails:
    - "Use concerns for shared behavior"
    - "Use service objects for complex logic"
    - "Use Hotwire for dynamic UI"
    - "Keep controllers thin"
