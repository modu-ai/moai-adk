# Elixir Language Patterns
# Common patterns for Elixir 1.17+ development
# Version: 1.0.0
# Last Updated: 2026-01-23

---
language: "elixir"
version: "1.17+"
description: "Common patterns for modern Elixir development"

# Language Features
features:
  pattern_matching:
    name: "Pattern Matching"
    description: "Destructuring and guards"
    example: |
      def handle_response({:ok, %{status: 200, body: body}}) do
        {:ok, Jason.decode!(body)}
      end

      def handle_response({:ok, %{status: status}}) when status in 400..499 do
        {:error, :client_error}
      end

      def handle_response({:error, reason}) do
        {:error, reason}
      end

  with_expression:
    name: "With Expression"
    description: "Sequential pattern matching"
    example: |
      def create_user(params) do
        with {:ok, validated} <- validate(params),
             {:ok, user} <- Repo.insert(User.changeset(%User{}, validated)),
             {:ok, _email} <- send_welcome_email(user) do
          {:ok, user}
        else
          {:error, %Ecto.Changeset{} = changeset} ->
            {:error, changeset}
          {:error, reason} ->
            {:error, reason}
        end
      end

  protocols:
    name: "Protocols"
    description: "Polymorphism via protocols"
    example: |
      defprotocol Serializable do
        @spec to_map(t) :: map()
        def to_map(data)
      end

      defimpl Serializable, for: User do
        def to_map(user) do
          %{id: user.id, name: user.name, email: user.email}
        end
      end

# OTP Patterns
otp:
  genserver:
    name: "GenServer"
    description: "Stateful server process"
    example: |
      defmodule Cache do
        use GenServer

        def start_link(opts \\ []) do
          GenServer.start_link(__MODULE__, %{}, opts)
        end

        def get(server, key) do
          GenServer.call(server, {:get, key})
        end

        def put(server, key, value) do
          GenServer.cast(server, {:put, key, value})
        end

        @impl true
        def init(state), do: {:ok, state}

        @impl true
        def handle_call({:get, key}, _from, state) do
          {:reply, Map.get(state, key), state}
        end

        @impl true
        def handle_cast({:put, key, value}, state) do
          {:noreply, Map.put(state, key, value)}
        end
      end

  supervisor:
    name: "Supervisor"
    description: "Supervision tree"
    example: |
      defmodule MyApp.Application do
        use Application

        def start(_type, _args) do
          children = [
            MyApp.Repo,
            {Phoenix.PubSub, name: MyApp.PubSub},
            MyAppWeb.Endpoint,
            {Task.Supervisor, name: MyApp.TaskSupervisor}
          ]

          opts = [strategy: :one_for_one, name: MyApp.Supervisor]
          Supervisor.start_link(children, opts)
        end
      end

# Phoenix Patterns
phoenix:
  liveview:
    name: "Phoenix LiveView"
    description: "Real-time server-rendered UI"
    example: |
      defmodule MyAppWeb.UserLive.Index do
        use MyAppWeb, :live_view

        def mount(_params, _session, socket) do
          {:ok, assign(socket, users: list_users())}
        end

        def handle_event("delete", %{"id" => id}, socket) do
          user = Accounts.get_user!(id)
          {:ok, _} = Accounts.delete_user(user)

          {:noreply,
           socket
           |> put_flash(:info, "User deleted")
           |> assign(users: list_users())}
        end

        defp list_users, do: Accounts.list_users()
      end

  context:
    name: "Context Pattern"
    description: "Domain boundary modules"
    example: |
      defmodule MyApp.Accounts do
        alias MyApp.Accounts.User
        alias MyApp.Repo

        def list_users do
          Repo.all(User)
        end

        def get_user!(id) do
          Repo.get!(User, id)
        end

        def create_user(attrs \\ %{}) do
          %User{}
          |> User.changeset(attrs)
          |> Repo.insert()
        end

        def update_user(%User{} = user, attrs) do
          user
          |> User.changeset(attrs)
          |> Repo.update()
        end
      end

# Testing Patterns
testing:
  exunit:
    name: "ExUnit"
    patterns:
      async_tests:
        description: "Async test cases"
        example: |
          defmodule MyApp.AccountsTest do
            use MyApp.DataCase, async: true

            alias MyApp.Accounts

            describe "users" do
              test "list_users/0 returns all users" do
                user = user_fixture()
                assert Accounts.list_users() == [user]
              end

              test "create_user/1 with valid data creates a user" do
                valid_attrs = %{name: "Test", email: "test@example.com"}

                assert {:ok, %User{} = user} = Accounts.create_user(valid_attrs)
                assert user.name == "Test"
              end
            end
          end

# Best Practices
best_practices:
  code_style:
    - "Use mix format for formatting"
    - "Use Credo for static analysis"
    - "Use Dialyzer for type checking"
    - "Prefer pattern matching over conditionals"

  otp:
    - "Use supervision trees"
    - "Let it crash philosophy"
    - "Use GenServer for stateful processes"
    - "Use Task for one-off async work"
