# Go Language Patterns
# Common patterns for Go 1.23+ development
# Version: 1.0.0
# Last Updated: 2026-01-22

---
language: "go"
version: "1.23+"
description: "Common patterns for modern Go development"

# Language Features
features:
  range_over_integers:
    name: "Range over Integers"
    description: "Direct iteration over integer ranges"
    example: |
      for i := range 10 {
          fmt.Println(i)
      }

  generics:
    name: "Improved Generics"
    description: "Better type inference for generics"
    example: |
      func Map[T, U any](slice []T, fn func(T) U) []U {
          result := make([]U, len(slice))
          for i, v := range slice {
              result[i] = fn(v)
          }
          return result
      }

# Web Framework Patterns
web_frameworks:
  fiber:
    name: "Fiber v3"
    description: "Express-inspired web framework"
    example: |
      package main

      import (
          "github.com/gofiber/fiber/v3"
          "github.com/gofiber/fiber/v3/middleware/cors"
          "github.com/gofiber/fiber/v3/middleware/logger"
          "github.com/gofiber/fiber/v3/middleware/recover"
      )

      func main() {
          app := fiber.New(fiber.Config{
              ErrorHandler: customErrorHandler,
              Prefork:       true,
          })

          app.Use(logger.New())
          app.Use(recover.New())
          app.Use(cors.New())

          api := app.Group("/api/v1")

          api.Get("/users", listUsers)
          api.Get("/users/:id", getUser)
          api.Post("/users", createUser)
          api.Put("/users/:id", updateUser)
          api.Delete("/users/:id", deleteUser)

          app.Listen(":3000")
      }

  gin:
    name: "Gin Web Framework"
    description: "High-performance HTTP framework"
    example: |
      package main

      import (
          "github.com/gin-contrib/cors"
          "github.com/gin-gonic/gin"
      )

      func main() {
          r := gin.Default()
          r.Use(cors.Default())

          api := r.Group("/api/v1")
          {
              api.GET("/users", listUsers)
              api.GET("/users/:id", getUser)
              api.POST("/users", createUser)
          }

          r.Run(":3000")
      }

    request_binding:
      description: "Request binding with validation"
      example: |
          type CreateUserRequest struct {
              Name  string `json:"name" binding:"required,min=2"`
              Email string `json:"email" binding:"required,email"`
          }

          func createUser(c *gin.Context) {
              var req CreateUserRequest
              if err := c.ShouldBindJSON(&req); err != nil {
                  c.JSON(400, gin.H{"error": err.Error()})
                  return
              }

              user := CreateUser(req)
              c.JSON(201, user)
          }

  echo:
    name: "Echo Web Framework"
    description: "Minimalist and extensible framework"
    example: |
      package main

      import (
          "github.com/labstack/echo/v4"
          "github.com/labstack/echo/v4/middleware"
      )

      func main() {
          e := echo.New()

          e.Use(middleware.Logger())
          e.Use(middleware.Recover())
          e.Use(middleware.CORS())

          api := e.Group("/api/v1")
          api.GET("/users", listUsers)
          api.POST("/users", createUser)

          e.Logger.Fatal(e.Start(":3000"))
      }

  chi:
    name: "Chi Router"
    description: "Lightweight, idiomatic router"
    example: |
      package main

      import (
          "github.com/go-chi/chi/v5"
          "github.com/go-chi/chi/v5/middleware"
      )

      func main() {
          r := chi.NewRouter()

          r.Use(middleware.Logger)
          r.Use(middleware.Recoverer)

          r.Route("/api/v1", func(r chi.Router) {
              r.Route("/users", func(r chi.Router) {
                  r.Get("/", listUsers)
                  r.Post("/", createUser)
                  r.Get("/{id}", getUser)
              })
          })

          http.ListenAndServe(":3000", r)
      }

# ORM Patterns
orm:
  gorm:
    name: "GORM 1.25"
    description: "Feature-rich ORM library"
    patterns:
      model_definition:
        description: "Model definition with tags"
        example: |
          type User struct {
              gorm.Model
              Name  string `gorm:"uniqueIndex;not null"`
              Email string `gorm:"uniqueIndex;not null"`
              Posts []Post `gorm:"foreignKey:AuthorID"`
          }

      query_patterns:
        description: "Common query patterns"
        example: |
          // Preload with limits
          db.Preload("Posts", func(db *gorm.DB) *gorm.DB {
              return db.Order("created_at DESC").Limit(10)
          }).First(&user, 1)

          // Transaction
          db.Transaction(func(tx *gorm.DB) error {
              if err := tx.Create(&user).Error; err != nil {
                  return err
              }
              return tx.Create(&profile).Error
          })

  sqlc:
    name: "sqlc Type-Safe SQL"
    description: "Generate type-safe SQL code"
    patterns:
      configuration:
        description: "sqlc.yaml configuration"
        example: |
          version: "2"
          sql:
            - schema: "schema.sql"
              queries: "query.sql"
              engine: "postgresql"
          go:
              package: "db"
              out: "db"
              sql_package: "pgx/v5"
              generate: true

      query_definition:
        description: "Query definitions in query.sql"
        example: |
          -- name: GetUser :one
          SELECT * FROM users
          WHERE id = $1;

          -- name: CreateUser :one
          INSERT INTO users (name, email)
          VALUES ($1, $2)
          RETURNING *;

# Concurrency Patterns
concurrency:
  errgroup:
    name: "Errgroup Pattern"
    description: "Coordinate goroutines with error handling"
    example: |
      import "golang.org/x/sync/errgroup"

      func fetchAllData() (*Result, error) {
          g, ctx := errgroup.WithContext(context.Background())

          var users []User
          var orders []Order

          g.Go(func() error {
              var err error
              users, err = fetchUsers(ctx)
              return err
          })

          g.Go(func() error {
              var err error
              orders, err = fetchOrders(ctx)
              return err
          })

          if err := g.Wait(); err != nil {
              return nil, err
          }

          return &Result{users, orders}, nil
      }

  worker_pool:
    name: "Worker Pool Pattern"
    description: "Limit concurrent goroutines"
    example: |
      func workerPool(jobs <-chan Job, results chan<- Result, n int) {
          var wg sync.WaitGroup

          for i := 0; i < n; i++ {
              wg.Add(1)
              go func() {
                  defer wg.Done()
                  for job := range jobs {
                      results <- processJob(job)
                  }
              }()
          }

          wg.Wait()
          close(results)
      }

  context_timeout:
    name: "Context with Timeout"
    description: "Handle timeouts gracefully"
    example: |
      func fetchData(ctx context.Context) (*Data, error) {
          ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
          defer cancel()

          data, err := fetchDataFromAPI(ctx)
          if errors.Is(err, context.DeadlineExceeded) {
              return nil, fmt.Errorf("timeout: %w", err)
          }
          return data, err
      }

# Testing Patterns
testing:
  table_driven:
    name: "Table-Driven Tests"
    description: "Test multiple cases efficiently"
    example: |
      func TestCreateUser(t *testing.T) {
          tests := []struct {
              name    string
              input   CreateUserInput
              wantErr bool
          }{
              {
                  name: "valid input",
                  input: CreateUserInput{
                      Name:  "Test User",
                      Email: "test@example.com",
                  },
                  wantErr: false,
              },
              {
                  name: "empty name",
                  input: CreateUserInput{
                      Email: "test@example.com",
                  },
                  wantErr: true,
              },
          }

          for _, tt := range tests {
              t.Run(tt.name, func(t *testing.T) {
                  err := service.Create(tt.input)
                  if (err != nil) != tt.wantErr {
                      t.Errorf("Create() error = %v, wantErr %v", err, tt.wantErr)
                  }
              })
          }
      }

  http_testing:
    name: "HTTP Testing"
    description: "Test HTTP handlers"
    example: |
      func TestGetUser(t *testing.T) {
          app := fiber.New()

          app.Get("/users/:id", getUser)

          req := httptest.NewRequest("GET", "/users/1", nil)
          resp, err := app.Test(req)

          if err != nil {
              t.Fatalf("Failed to send request: %v", err)
          }

          if resp.StatusCode != 200 {
              t.Errorf("Expected status 200, got %d", resp.StatusCode)
          }
      }

# CLI Patterns
cli:
  cobra_viper:
    name: "Cobra with Viper"
    description: "CLI framework with configuration"
    example: |
      package cmd

      import (
          "github.com/spf13/cobra"
          "github.com/spf13/viper"
      )

      var rootCmd = &cobra.Command{
          Use:   "myapp",
          Short: "My application",
      }

      func Execute() {
          if err := rootCmd.Execute(); err != nil {
              log.Fatal(err)
          }
      }

      func init() {
          rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file")
          viper.BindPFlag("config", rootCmd.PersistentFlags().Lookup("config"))

          viper.SetEnvPrefix("MYAPP")
          viper.AutomaticEnv()
      }

# Best Practices
best_practices:
  error_handling:
    - "Always check errors"
    - "Wrap errors with context"
    - "Use custom error types"
    - "Handle errors early"

  concurrency:
    - "Prefer channels over shared memory"
    - "Use context for cancellation"
    - "Limit goroutines with worker pools"
    - "Always handle goroutine errors"

  code_organization:
    - "Keep packages small and focused"
    - "Use interfaces for abstraction"
    - "Follow standard project layout"
    - "Separate concerns clearly"

  performance:
    - "Use sync.Pool for object reuse"
    - "Prefer bufio for I/O"
    - "Profile before optimizing"
    - "Use pprof for profiling"
