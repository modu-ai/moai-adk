# Kotlin Language Patterns
# Common patterns for Kotlin 2.0+ development
# Version: 1.0.0
# Last Updated: 2026-01-23

---
language: "kotlin"
version: "2.0+"
description: "Common patterns for modern Kotlin development"

# Language Features
features:
  coroutines:
    name: "Coroutines"
    description: "Structured concurrency"
    example: |
      suspend fun fetchUsers(): List<User> = coroutineScope {
          val users = async { userRepository.getAll() }
          val profiles = async { profileRepository.getAll() }
          users.await().map { user ->
              user.copy(profile = profiles.await().find { it.userId == user.id })
          }
      }

  sealed_classes:
    name: "Sealed Classes"
    description: "Exhaustive when expressions"
    example: |
      sealed class Result<out T> {
          data class Success<T>(val data: T) : Result<T>()
          data class Error(val message: String) : Result<Nothing>()
          data object Loading : Result<Nothing>()
      }

      fun handleResult(result: Result<User>) = when (result) {
          is Result.Success -> showUser(result.data)
          is Result.Error -> showError(result.message)
          Result.Loading -> showLoading()
      }

  context_receivers:
    name: "Context Receivers"
    description: "Multiple receiver contexts"
    example: |
      context(LoggerContext, TransactionContext)
      suspend fun createUser(user: User): User {
          log.info("Creating user: ${user.email}")
          return transaction {
              userRepository.save(user)
          }
      }

# Web Framework Patterns
web_frameworks:
  ktor:
    name: "Ktor 3.x"
    patterns:
      routing:
        description: "Type-safe routing"
        example: |
          fun Application.configureRouting() {
              routing {
                  route("/api/users") {
                      get {
                          call.respond(userService.getAll())
                      }
                      get("/{id}") {
                          val id = call.parameters["id"]?.toIntOrNull()
                              ?: return@get call.respond(HttpStatusCode.BadRequest)
                          userService.getById(id)?.let { call.respond(it) }
                              ?: call.respond(HttpStatusCode.NotFound)
                      }
                      post {
                          val user = call.receive<CreateUserRequest>()
                          call.respond(HttpStatusCode.Created, userService.create(user))
                      }
                  }
              }
          }

      dependency_injection:
        description: "Koin DI setup"
        example: |
          val appModule = module {
              single<Database> { PostgresDatabase(get()) }
              single<UserRepository> { UserRepositoryImpl(get()) }
              factory { UserService(get()) }
          }

          fun Application.main() {
              install(Koin) {
                  modules(appModule)
              }
          }

# Database Patterns
database:
  exposed:
    name: "Exposed ORM"
    patterns:
      dsl:
        description: "DSL query pattern"
        example: |
          object Users : Table() {
              val id = integer("id").autoIncrement()
              val name = varchar("name", 50)
              val email = varchar("email", 100).uniqueIndex()
              override val primaryKey = PrimaryKey(id)
          }

          suspend fun findUserByEmail(email: String): User? = dbQuery {
              Users.select { Users.email eq email }
                  .map { it.toUser() }
                  .singleOrNull()
          }

# Testing Patterns
testing:
  kotest:
    name: "Kotest"
    patterns:
      behavior_spec:
        description: "BDD style tests"
        example: |
          class UserServiceTest : BehaviorSpec({
              given("a user service") {
                  val repository = mockk<UserRepository>()
                  val service = UserService(repository)

                  `when`("getting an existing user") {
                      coEvery { repository.findById(1) } returns User(1, "Test")

                      then("it should return the user") {
                          val user = service.getUser(1)
                          user shouldNotBe null
                          user?.name shouldBe "Test"
                      }
                  }
              }
          })

# Best Practices
best_practices:
  code_style:
    - "Use data classes for DTOs"
    - "Use sealed classes for state"
    - "Prefer immutability (val over var)"
    - "Use extension functions for utilities"

  coroutines:
    - "Use structured concurrency"
    - "Handle exceptions with CoroutineExceptionHandler"
    - "Use Flow for reactive streams"
    - "Avoid GlobalScope"
