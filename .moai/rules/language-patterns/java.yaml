# Java Language Patterns
# Common patterns for Java 21+ development
# Version: 1.0.0
# Last Updated: 2026-01-22

---
language: "java"
version: "21+"
description: "Common patterns for modern Java development"

# Language Features
features:
  pattern_matching:
    name: "Pattern Matching for instanceof"
    description: "Combine type check and binding"
    example: |
      if (obj instanceof String s) {
          System.out.println(s.length());
      }

  records:
    name: "Records for Immutable Data"
    description: "Concise data carriers"
    example: |
      public record User(String name, String email) {
          public User {
              if (name == null || name.isBlank()) {
                  throw new IllegalArgumentException("Name required");
              }
          }
      }

  sealed_classes:
    name: "Sealed Classes for Restricted Hierarchies"
    description: "Control inheritance"
    example: |
      public sealed interface Shape
          permits Circle, Rectangle, Triangle {

          double area();
      }

      public record Circle(double radius) implements Shape {
          public double area() {
              return Math.PI * radius * radius;
          }
      }

  virtual_threads:
    name: "Virtual Threads for Concurrency"
    description: "Lightweight threads"
    example: |
      try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
          IntStream.range(0, 10_000).forEach(i -> {
              executor.submit(() -> {
                  Thread.sleep(Duration.ofSeconds(1));
                  return i;
              });
          });
      }

  string_templates:
    name: "String Templates"
    description: "Safe string interpolation"
    example: |
      String name = "World";
      String message = STR."Hello, \{name}!";
      String json = JSON."""
          {
              "name": "\{name}",
              "value": "\{computeValue()}"
          }
          """;

  switch_expressions:
    name: "Switch Expressions"
    description: "Enhanced switch syntax"
    example: |
      int result = switch (day) {
          case MONDAY, FRIDAY, SUNDAY -> 6;
          case TUESDAY -> 7;
          case THURSDAY, SATURDAY -> 8;
          case WEDNESDAY -> 9;
      };

  unnamed_patterns:
    name: "Unnamed Patterns and Variables"
    description: "Ignore unmatched values"
    example: |
      if (obj instanceof String _) {
          System.out.println("It's a string");
      }

      // Ignore exception
      try {
          process();
      } catch (Exception _) {
          log.error("Failed");
      }

# Spring Boot Patterns
spring_boot:
  version: "3.3+"
  patterns:
    rest_controller:
      description: "RESTful API controller"
      example: |
        @RestController
        @RequestMapping("/api/users")
        @RequiredArgsConstructor
        public class UserController {

            private final UserService userService;

            @GetMapping("/{id}")
            public ResponseEntity<User> getUser(@PathVariable UUID id) {
                return ResponseEntity.ok(userService.findById(id));
            }

            @PostMapping
            public ResponseEntity<User> createUser(
                @Valid @RequestBody CreateUserRequest request) {
                User user = userService.create(request);
                return ResponseEntity.status(HttpStatus.CREATED)
                    .body(user);
            }
        }

    service_layer:
      description: "Service layer with transactions"
      example: |
        @Service
        @RequiredArgsConstructor
        @Transactional
        public class UserService {

            private final UserRepository userRepository;
            private final PasswordEncoder passwordEncoder;

            public User create(CreateUserRequest request) {
                User user = new User();
                user.setName(request.name());
                user.setEmail(request.email());
                user.setPassword(
                    passwordEncoder.encode(request.password())
                );
                return userRepository.save(user);
            }

            @Transactional(readOnly = true)
            public Optional<User> findById(UUID id) {
                return userRepository.findById(id);
            }
        }

    repository:
      description: "Spring Data JPA repository"
      example: |
        public interface UserRepository
            extends JpaRepository<User, UUID> {

            Optional<User> findByEmail(String email);

            @Query("SELECT u FROM User u WHERE u.name LIKE :name%")
            List<User> findByNameStartingWith(
                @Param("name") String name
            );

            @EntityGraph(attributePaths = {"posts"})
            Optional<User> findByIdWithPosts(UUID id);
        }

    configuration:
      description: "Configuration properties"
      example: |
        @ConfigurationProperties(prefix = "app")
        @Validated
        public record AppProperties(
            @NotBlank String name,
            @Min(1024) @Max(65535) int port,
            @Valid Database database
        ) {
            public record Database(
                @NotBlank String url,
                @NotBlank String username,
                @NotBlank String password,
                @Min(1) int maxConnections
            ) {}
        }

    exception_handling:
      description: "Global exception handler"
      example: |
        @RestControllerAdvice
        public class GlobalExceptionHandler {

            @ExceptionHandler(MethodArgumentNotValidException.class)
            public ResponseEntity<ErrorResponse> handleValidation(
                MethodArgumentNotValidException ex
            ) {
                Map<String, String> errors = new HashMap<>();
                ex.getBindingResult().getFieldErrors().forEach(error ->
                    errors.put(error.getField(), error.getDefaultMessage())
                );

                return ResponseEntity
                    .status(HttpStatus.BAD_REQUEST)
                    .body(new ErrorResponse(errors));
            }
        }

# Testing Patterns
testing:
  junit5:
    name: "JUnit 5 Testing"
    patterns:
      basic_test:
        description: "Basic test structure"
        example: |
          @Test
          @DisplayName("Should create user with valid data")
          void shouldCreateUser() {
              // Given
              CreateUserRequest request = new CreateUserRequest(
                  "John Doe",
                  "john@example.com",
                  "password123"
              );

              // When
              User user = userService.create(request);

              // Then
              assertNotNull(user.getId());
              assertEquals("John Doe", user.getName());
              assertEquals("john@example.com", user.getEmail());
          }

      parametrized_test:
        description: "Parametrized tests"
        example: |
          @ParameterizedTest
          @MethodSource("provideInvalidEmails")
          @DisplayName("Should reject invalid email")
          void shouldRejectInvalidEmail(String email) {
              assertThrows(
                  ValidationException.class,
                  () -> new CreateUserRequest("Name", email, "pass")
              );
          }

          private static Stream<Arguments> provideInvalidEmails() {
              return Stream.of(
                  Arguments.of("invalid"),
                  Arguments.of("@example.com"),
                  Arguments.of("user@")
              );
          }

      mockito:
        description: "Mockito for mocking"
        example: |
          @ExtendWith(MockitoExtension.class)
          class UserServiceTest {

              @Mock
              private UserRepository userRepository;

              @InjectMocks
              private UserService userService;

              @Test
              void shouldReturnUserWhenExists() {
                  User user = new User("John", "john@example.com");
                  when(userRepository.findById(any(UUID.class)))
                      .thenReturn(Optional.of(user));

                  Optional<User> result = userService.findById(UUID.randomUUID());

                  assertTrue(result.isPresent());
                  assertEquals("John", result.get().getName());
              }
          }

# Build Tools
build_tools:
  maven:
    name: "Maven"
    example: |
      <?xml version="1.0" encoding="UTF-8"?>
      <project xmlns="http://maven.apache.org/POM/4.0.0">
          <modelVersion>4.0.0</modelVersion>

          <parent>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-parent</artifactId>
              <version>3.3.0</version>
          </parent>

          <groupId>com.example</groupId>
          <artifactId>myapp</artifactId>
          <version>1.0.0</version>

          <properties>
              <java.version>21</java.version>
          </properties>

          <dependencies>
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-starter-web</artifactId>
              </dependency>
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-starter-data-jpa</artifactId>
              </dependency>
              <dependency>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-starter-validation</artifactId>
              </dependency>
              <dependency>
                  <groupId>com.github.database-rider</groupId>
                  <artifactId>rider-core</artifactId>
                  <scope>test</scope>
              </dependency>
          </dependencies>
      </project>

  gradle:
    name: "Gradle (Kotlin DSL)"
    example: |
      plugins {
          id("java")
          id("org.springframework.boot") version "3.3.0"
          id("io.spring.dependency-management") version "1.1.4"
      }

      group = "com.example"
      version = "1.0.0"

      java {
          sourceCompatibility = JavaVersion.VERSION_21
      }

      repositories {
          mavenCentral()
      }

      dependencies {
          implementation("org.springframework.boot:spring-boot-starter-web")
          implementation("org.springframework.boot:spring-boot-starter-data-jpa")
          implementation("org.springframework.boot:spring-boot-starter-validation")

          testImplementation("org.springframework.boot:spring-boot-starter-test")
          testImplementation("com.github.database-rider:rider-core")
      }

      tasks.withType<Test> {
          useJUnitPlatform()
      }

# Best Practices
best_practices:
  code_style:
    - "Use records for immutable data"
    - "Prefer sealed classes for restricted hierarchies"
    - "Use pattern matching for cleaner code"
    - "Leverage virtual threads for concurrency"

  spring_boot:
    - "Use constructor injection"
    - "Apply validation at service layer"
    - "Use @Transactional for database operations"
    - "Implement proper exception handling"

  testing:
    - "Write tests for business logic"
    - "Use parametrized tests for multiple cases"
    - "Mock dependencies appropriately"
    - "Test edge cases and error conditions"

  performance:
    - "Use virtual threads for I/O-bound operations"
    - "Optimize database queries"
    - "Implement proper caching"
    - "Profile before optimizing"
