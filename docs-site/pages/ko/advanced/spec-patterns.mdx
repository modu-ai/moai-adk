---
title: Advanced SPEC Patterns (ê³ ê¸‰ ëª…ì„¸ ì‘ì„±)
description: MoAI-ADK - ë³µì¡í•œ ìš”êµ¬ì‚¬í•­, ì˜ì¡´ì„±, í™•ì¥ì„±, ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ SPEC ì‘ì„± ê°€ì´ë“œ
---

# Advanced SPEC Patterns: ë³µì¡í•œ ìš”êµ¬ì‚¬í•­ ëª…ì„¸

ì´ ê°€ì´ë“œëŠ” **ë‹¨ìˆœí•œ SPECì„ ë„˜ì–´ì„œ** ë³µì¡í•œ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê³  ë¬¸ì„œí™”í•˜ëŠ” Advanced íŒ¨í„´ì„ ë‹¤ë£¹ë‹ˆë‹¤.

---

## ğŸ“Š Pattern 1: ì˜ì¡´ì„± ìˆëŠ” SPEC ì²´ì¸

### ì‹œë‚˜ë¦¬ì˜¤

```
SPEC-AUTH-001 (ì‚¬ìš©ì ì¸ì¦)
    â†“ ì˜ì¡´
SPEC-USER-001 (ì‚¬ìš©ì ê´€ë¦¬)
    â†“ ì˜ì¡´
SPEC-PRODUCT-001 (ìƒí’ˆ ê´€ë¦¬)
```

### SPEC ì •ì˜

```yaml
# SPEC-AUTH-001/spec.md
id: SPEC-AUTH-001
title: ì‚¬ìš©ì ì¸ì¦ ì‹œìŠ¤í…œ
dependencies: []
next_spec: SPEC-USER-001

# SPEC-USER-001/spec.md
id: SPEC-USER-001
title: ì‚¬ìš©ì ê´€ë¦¬ ì‹œìŠ¤í…œ
dependencies:
  - SPEC-AUTH-001
next_spec: SPEC-PRODUCT-001

# SPEC-PRODUCT-001/spec.md
id: SPEC-PRODUCT-001
title: ìƒí’ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ
dependencies:
  - SPEC-AUTH-001
  - SPEC-USER-001
next_spec: null
```

### ìë™ ì‹¤í–‰ ìˆœì„œ

```
tdd-implementer:
  1ï¸âƒ£ SPEC-AUTH-001 êµ¬í˜„ (ì˜ì¡´ì„± ì—†ìŒ)
  2ï¸âƒ£ SPEC-USER-001 êµ¬í˜„ (SPEC-AUTH-001 í•„ìš”)
  3ï¸âƒ£ SPEC-PRODUCT-001 êµ¬í˜„ (AUTH, USER í•„ìš”)
  
  âœ… ì˜ì¡´ì„± ìë™ ê²€ì¦
  âœ… ìˆœì„œ ìë™ ê³„íš
  âœ… ë³‘ë ¬ ë¶ˆê°€ ì•Œë¦¼
```

---

## ğŸ”„ Pattern 2: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ SPEC

### ì•„í‚¤í…ì²˜

```
â”Œâ”€ API Gateway
â”‚  â”œâ”€ Auth Service (SPEC-AUTH-001)
â”‚  â”œâ”€ User Service (SPEC-USER-001)
â”‚  â”œâ”€ Product Service (SPEC-PRODUCT-001)
â”‚  â””â”€ Order Service (SPEC-ORDER-001)
â”‚      â””â”€ Cache Layer (Redis)
â”‚      â””â”€ Message Queue (RabbitMQ)
```

### SPEC êµ¬ì„±

ê° ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ëŠ” ë…ë¦½ì ì¸ SPEC:

```yaml
# SPEC-AUTH-001
name: Auth Service
port: 5001
database: postgres
dependencies:
  - external: JWT library
  - external: bcrypt

# SPEC-USER-001
name: User Service
port: 5002
database: postgres
dependencies:
  - service: SPEC-AUTH-001 (API call)

# SPEC-ORDER-001
name: Order Service
port: 5004
database: postgres
cache: redis:6379
message_queue: rabbitmq:5672
dependencies:
  - service: SPEC-AUTH-001
  - service: SPEC-PRODUCT-001
```

### í†µí•© í…ŒìŠ¤íŠ¸

```python
# tests/integration/test_order_flow.py

def test_order_creation_with_auth():
    """
    Given: ì¸ì¦ëœ ì‚¬ìš©ì
    When: ìƒí’ˆ êµ¬ë§¤ ì£¼ë¬¸ ìƒì„±
    Then: ëª¨ë“  ì„œë¹„ìŠ¤ ì •ìƒ ì‘ë™
    """
    # 1. Auth Service: ë¡œê·¸ì¸
    token = auth_service.login("user@example.com", "password")
    
    # 2. User Service: ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    user = user_service.get_profile(token)
    
    # 3. Product Service: ìƒí’ˆ ê²€ì¦
    product = product_service.get_product(123)
    
    # 4. Order Service: ì£¼ë¬¸ ìƒì„±
    order = order_service.create_order(user_id, product_id, quantity=1)
    
    # 5. Message Queue: ì£¼ë¬¸ ì²˜ë¦¬ ì‹œì‘
    assert queue.has_message("order.created")
    
    # 6. Cache: ì£¼ë¬¸ ì¡°íšŒ ì„±ëŠ¥ í™•ì¸
    cached_order = cache.get(f"order:{order.id}")
    assert cached_order is not None
```

---

## ğŸ”€ Pattern 3: ì¡°ê±´ë¶€ ê¸°ëŠ¥ (Feature Flag)

### SPECì— ì¡°ê±´ ì¶”ê°€

```yaml
# SPEC-PAYMENT-001
title: ê²°ì œ ì‹œìŠ¤í…œ

UBIQUITOUS:
  - ëª¨ë“  ê²°ì œëŠ” PCI-DSS ì¤€ìˆ˜
  - ëª¨ë“  ê¸ˆì•¡ì€ ìµœì†Œ 100ì›

EVENT-DRIVEN:
  - ì‚¬ìš©ìê°€ ê²°ì œ ìš”ì²­ ì‹œ â†’ ê²°ì œ ì²˜ë¦¬
  - ê²°ì œ ì™„ë£Œ ì‹œ â†’ ì£¼ë¬¸ í™•ì •
  
  CONDITIONAL (Feature Flag):
    - IF feature_flag.advanced_payment THEN
        - í• ë¶€ ê²°ì œ ì§€ì›
        - êµ¬ë… ìë™ ê²°ì œ
    - IF feature_flag.crypto_payment THEN
        - ì•”í˜¸í™”í ê²°ì œ ì§€ì›

OPTIONAL:
  - ê²°ì œ ì‹œë®¬ë ˆì´ì…˜ (í…ŒìŠ¤íŠ¸ìš©)
  - í™˜ë¶ˆ ìë™í™”
```

### êµ¬í˜„

```python
# src/payment.py

class PaymentProcessor:
    def process_payment(self, amount, method):
        # ê¸°ë³¸ ê²°ì œ (í•­ìƒ í¬í•¨)
        transaction = self._process_basic(amount, method)
        
        # ê³ ê¸‰ ê²°ì œ (Feature Flag)
        if feature_flags.advanced_payment:
            if method == "installment":
                transaction = self._process_installment(transaction)
        
        # ì•”í˜¸í™”í (Feature Flag)
        if feature_flags.crypto_payment:
            if method == "bitcoin":
                transaction = self._process_crypto(transaction)
        
        return transaction
```

---

## ğŸ“ˆ Pattern 4: ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­ ëª…ì‹œ

### SPECì— ì„±ëŠ¥ ê¸°ì¤€ ì¶”ê°€

```yaml
# SPEC-PRODUCT-001
title: ìƒí’ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ

PERFORMANCE_REQUIREMENTS:
  response_time:
    - GET /products: < 100ms (p95)
    - POST /products: < 200ms (p99)
    - GET /products/{id}: < 50ms (p95)
  
  throughput:
    - Min: 1,000 req/s
    - Peak: 10,000 req/s
    - Max Burst: 50,000 req/s
  
  database:
    - Query time: < 50ms (p95)
    - Connection pool: 20
    - Max connections: 100
  
  caching:
    - Cache hit rate: > 80%
    - Cache TTL: 300s (5ë¶„)
```

### í…ŒìŠ¤íŠ¸

```python
# tests/test_product_performance.py

def test_get_products_response_time():
    """P95 ì‘ë‹µ ì‹œê°„ < 100ms"""
    times = []
    for _ in range(1000):
        start = time.time()
        response = client.get("/products")
        times.append((time.time() - start) * 1000)  # ms
    
    p95 = numpy.percentile(times, 95)
    assert p95 < 100, f"P95 ì‘ë‹µ ì‹œê°„: {p95}ms"

def test_cache_hit_rate():
    """ìºì‹œ íˆíŠ¸ìœ¨ > 80%"""
    cache.clear()
    
    hits = 0
    total = 0
    for product_id in range(1, 101):
        total += 1
        if cache.get(f"product:{product_id}"):
            hits += 1
        else:
            cache.set(f"product:{product_id}", get_product(product_id))
    
    hit_rate = hits / total
    assert hit_rate > 0.8
```

---

## ğŸ”’ Pattern 5: ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ëª…ì‹œ

### SPECì— ë³´ì•ˆ ì¶”ê°€

```yaml
# SPEC-AUTH-001
title: ì‚¬ìš©ì ì¸ì¦

SECURITY_REQUIREMENTS:
  authentication:
    - Method: JWT (RS256)
    - Token lifetime: 1ì‹œê°„
    - Refresh token: 7ì¼
    - Token rotation: í•„ìˆ˜
  
  password_policy:
    - Min length: 12ì
    - Complexity: ëŒ€ì†Œë¬¸ì + ìˆ«ì + íŠ¹ìˆ˜ë¬¸ì
    - Hash: bcrypt (cost >= 12)
    - History: ë§ˆì§€ë§‰ 5ê°œ ë¹„ë°€ë²ˆí˜¸ ë¶ˆê°€
  
  encryption:
    - Transport: TLS 1.3+
    - Database: AES-256-GCM
    - Sensitive data: PII ì•”í˜¸í™” í•„ìˆ˜
  
  logging:
    - Log failed login: í•„ìˆ˜
    - Audit trail: 30ì¼ ë³´ê´€
    - Log sensitive data: ê¸ˆì§€ (ì•”í˜¸í™” í‚¤, í† í° ë“±)
```

### í…ŒìŠ¤íŠ¸

```python
# tests/security/test_auth_security.py

def test_password_hashing():
    """ë¹„ë°€ë²ˆí˜¸ëŠ” bcryptë¡œ í•´ì‹±"""
    hashed = hash_password("TestPassword123!")
    assert hashed.startswith("$2a$") or hashed.startswith("$2b$")
    assert verify_password("TestPassword123!", hashed)
    assert not verify_password("WrongPassword", hashed)

def test_jwt_expiration():
    """JWT í† í° 1ì‹œê°„ í›„ ë§Œë£Œ"""
    token = create_token(user_id=1, expires_in=3600)
    
    # ì¦‰ì‹œ: ìœ íš¨
    assert is_valid_token(token)
    
    # 3600ì´ˆ í›„: ë§Œë£Œ
    with freeze_time() as frozen_time:
        frozen_time.move_to(frozen_time() + 3601)
        assert not is_valid_token(token)

def test_no_sensitive_data_in_logs():
    """ë¡œê·¸ì— ë¯¼ê°í•œ ë°ì´í„° ì—†ìŒ"""
    logs = capture_logs()
    assert "password" not in logs.lower()
    assert "secret" not in logs.lower()
    assert "token" not in logs.lower()
```

---

## ğŸŒ Pattern 6: ë‹¤êµ­ì–´ & ì§€ì—­í™”

### SPECì— i18n ì¶”ê°€

```yaml
# SPEC-PRODUCT-001
title: ìƒí’ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ

INTERNATIONALIZATION:
  supported_languages:
    - ko (Korean) - ê¸°ë³¸
    - en (English)
    - ja (Japanese)
    - zh (Chinese)
  
  currency:
    - KRW (â‚©) - ê¸°ë³¸
    - USD ($)
    - JPY (Â¥)
    - CNY (Â¥)
  
  date_format:
    - ko: YYYY.MM.DD
    - en: MM/DD/YYYY
    - ja: YYYYå¹´MMæœˆDDæ—¥
  
  translation_keys:
    - product.title
    - product.description
    - product.price
    - error.product_not_found
```

### êµ¬í˜„

```python
# src/i18n.py

class LocalizationService:
    def __init__(self, language="ko", currency="KRW"):
        self.language = language
        self.currency = currency
    
    def translate(self, key):
        """product.title â†’ "ìƒí’ˆëª…" (í•œêµ­ì–´)"""
        translations = {
            "ko": {"product.title": "ìƒí’ˆëª…"},
            "en": {"product.title": "Product Name"},
            "ja": {"product.title": "å•†å“å"},
        }
        return translations[self.language].get(key, key)
    
    def format_price(self, amount):
        """100000 â†’ â‚©100,000 (í•œêµ­ì–´)"""
        formats = {
            "KRW": f"â‚©{amount:,}",
            "USD": f"${amount:,.2f}",
            "JPY": f"Â¥{amount:,}",
        }
        return formats[self.currency]
```

---

## ğŸ¯ Best Practices

### âœ… Do's

- âœ… ì˜ì¡´ì„± ëª…í™•íˆ ì •ì˜
- âœ… ì„±ëŠ¥ ê¸°ì¤€ ìˆ˜ì¹˜í™”
- âœ… ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ êµ¬ì²´í™”
- âœ… ì¡°ê±´ë¶€ ê¸°ëŠ¥ Feature Flag ì‚¬ìš©
- âœ… í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ë¨¼ì € ì‘ì„±

### âŒ Don'ts

- âŒ "ë¹¨ë¼ì•¼ í•œë‹¤" (ìˆ˜ì¹˜ í•„ìˆ˜)
- âŒ "ì•ˆì „í•´ì•¼ í•œë‹¤" (êµ¬ì²´ì  ë°©ë²•)
- âŒ ì˜ì¡´ì„± ìˆœí™˜ ì°¸ì¡°
- âŒ ë¶ˆê°€ëŠ¥í•œ ìš”êµ¬ì‚¬í•­
- âŒ í…ŒìŠ¤íŠ¸ ì—†ëŠ” SPEC

---

## ğŸ“š ì°¸ê³ 

- [SPEC-First TDD](/ko/concepts/spec-first-tdd)
- [EARS íŒ¨í„´](/ko/concepts/ears-guide)
- [TAG System](/ko/concepts/tag-system)

