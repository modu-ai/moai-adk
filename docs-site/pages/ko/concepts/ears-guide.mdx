---
title: EARS 가이드 - 요구사항 명시 방법
description: EARS 5가지 패턴으로 명확한 요구사항 작성하기
---

# EARS 가이드 - 요구사항 명시 방법

## 개요

**EARS** (Easy Approach to Requirements Syntax)는 자연스러운 언어로 명확하고 검증 가능한 요구사항을 작성하는 방법입니다. MoAI-ADK는 EARS 패턴을 사용하여 SPEC을 작성합니다.

### EARS의 5가지 패턴

1. **UBIQUITOUS (보편적)**: 항상 만족해야 하는 요구사항
2. **EVENT-DRIVEN (이벤트 기반)**: 특정 이벤트 발생 시 수행할 요구사항
3. **STATE-DRIVEN (상태 기반)**: 특정 상태에서 유지해야 할 요구사항
4. **OPTIONAL (선택사항)**: 필요에 따라 구현할 수 있는 요구사항
5. **UNWANTED (제약사항)**: 절대로 하면 안 되는 것

---

## 1️⃣ UBIQUITOUS (보편적)

### 정의

시스템이 **항상** 만족해야 하는 조건이나 동작입니다. 모든 상황에서 무조건 지켜야 합니다.

### 패턴

```
시스템은 [조건/동작]해야 한다
```

### 예시

```markdown
## UBIQUITOUS (보편적)

- 시스템은 모든 사용자 입력을 검증해야 한다
- 시스템은 모든 API 응답을 로깅해야 한다
- 시스템은 모든 민감한 정보를 암호화하여 저장해야 한다
- 시스템은 모든 트랜잭션을 감사(audit) 기록해야 한다
- 시스템은 에러 발생 시 사용자 친화적인 메시지를 표시해야 한다
```

### 적용 사례

**금융 시스템**:
```markdown
- 시스템은 모든 금전 거래를 기록해야 한다
- 시스템은 모든 사용자 작업을 감시해야 한다
- 시스템은 모든 데이터베이스 변경을 로깅해야 한다
```

**이메일 서비스**:
```markdown
- 시스템은 모든 이메일을 스팸 필터링해야 한다
- 시스템은 모든 첨부파일을 바이러스 검사해야 한다
- 시스템은 모든 사용자 메일을 자동 백업해야 한다
```

### 특징

- ✅ 조건 없음 (IF가 없음)
- ✅ 항상 적용됨
- ✅ 높은 우선순위
- ✅ 비용 높음 (항상 실행되어야 하므로)

---

## 2️⃣ EVENT-DRIVEN (이벤트 기반)

### 정의

사용자 액션이나 시스템 이벤트가 발생했을 때 수행해야 할 요구사항입니다.

### 패턴

```
WHEN [이벤트가 발생하면]
  시스템은 [동작]해야 한다
  AND 시스템은 [다른 동작]해야 한다
```

### 예시

```markdown
## EVENT-DRIVEN (이벤트 기반)

### 로그인 이벤트
- WHEN 사용자가 로그인하면
  - 시스템은 비밀번호를 검증해야 한다
  - 시스템은 JWT 토큰을 발급해야 한다
  - 시스템은 로그인 시간을 기록해야 한다

### 결제 이벤트
- WHEN 사용자가 결제를 시작하면
  - 시스템은 카드 유효성을 확인해야 한다
  - 시스템은 결제 금액이 계정 한도 이내인지 확인해야 한다
  - 시스템은 결제 기록을 저장해야 한다

### 오류 발생 이벤트
- WHEN 데이터베이스 연결이 실패하면
  - 시스템은 재연결을 3번까지 시도해야 한다
  - 시스템은 관리자에게 알림을 보내야 한다
  - 시스템은 사용자에게 "일시적 오류" 메시지를 표시해야 한다
```

### 적용 사례

**전자상거래**:
```markdown
- WHEN 사용자가 장바구니에 상품을 추가하면
  - 시스템은 재고를 확인해야 한다
  - 시스템은 장바구니를 저장해야 한다
  - 시스템은 사용자에게 추가 완료 메시지를 표시해야 한다

- WHEN 사용자가 주문을 확인하면
  - 시스템은 결제를 처리해야 한다
  - 시스템은 재고를 감소시켜야 한다
  - 시스템은 주문 확인 이메일을 발송해야 한다
```

**소셜 미디어**:
```markdown
- WHEN 사용자가 팔로우 요청을 보내면
  - 시스템은 팔로우 관계를 생성해야 한다
  - 시스템은 팔로우 알림을 발송해야 한다
  - 시스템은 피드를 업데이트해야 한다
```

### 특징

- ✅ 명확한 트리거 (WHEN)
- ✅ 순차적 동작 (AND로 연결)
- ✅ 조건부 실행
- ✅ 테스트 용이 (테스트 케이스 명확)

---

## 3️⃣ STATE-DRIVEN (상태 기반)

### 정의

시스템이 특정 상태에 있을 때 **지속적으로** 유지해야 할 조건입니다.

### 패턴

```
WHILE [상태가 유지되는 동안]
  시스템은 [조건]을 유지해야 한다

WHEN [상태가 변경되면]
  시스템은 [새로운 동작]해야 한다
```

### 예시

```markdown
## STATE-DRIVEN (상태 기반)

### 로그인 상태
- WHILE 사용자가 로그인 상태이면
  - 시스템은 세션 토큰을 검증해야 한다
  - 시스템은 사용자 접근 권한을 확인해야 한다
  - 시스템은 타이밍 아웃을 30분으로 설정해야 한다

- WHEN 사용자가 로그아웃하면
  - 시스템은 세션을 종료해야 한다
  - 시스템은 토큰을 무효화해야 한다

### 로그아웃 상태
- WHILE 사용자가 로그아웃 상태이면
  - 시스템은 보호된 리소스에 접근을 거부해야 한다
  - 시스템은 로그인 페이지로 리디렉션해야 한다

### 결제 처리 중 상태
- WHILE 결제가 처리 중이면
  - 시스템은 결제 상태를 모니터링해야 한다
  - 시스템은 중복 결제를 방지해야 한다
  - 시스템은 타임아웃을 60초로 설정해야 한다

- WHEN 결제가 완료되면
  - 시스템은 주문을 확정해야 한다
  - 시스템은 사용자에게 확인 이메일을 발송해야 한다
```

### 적용 사례

**온라인 게임**:
```markdown
- WHILE 플레이어가 게임 중이면
  - 시스템은 플레이어 위치를 업데이트해야 한다
  - 시스템은 다른 플레이어와의 상호작용을 처리해야 한다
  - 시스템은 게임 진행을 저장해야 한다

- WHEN 플레이어가 게임을 종료하면
  - 시스템은 최종 점수를 저장해야 한다
  - 시스템은 플레이어를 로비로 돌려보내야 한다
```

**클라우드 스토리지**:
```markdown
- WHILE 파일 업로드가 진행 중이면
  - 시스템은 업로드 진행률을 보여줘야 한다
  - 시스템은 대역폭을 제한해야 한다
  - 시스템은 재시도 메커니즘을 유지해야 한다

- WHEN 업로드가 완료되면
  - 시스템은 파일을 저장해야 한다
  - 시스템은 사용자에게 완료 알림을 보내야 한다
```

### 특징

- ✅ 지속적 조건 (WHILE)
- ✅ 상태 전환 (WHEN)
- ✅ 시간 기반 동작
- ✅ 모니터링 필요

---

## 4️⃣ OPTIONAL (선택사항)

### 정의

**나중에 구현할 수 있는** 부가 기능이나 개선사항입니다. 필수는 아니지만 있으면 좋은 기능입니다.

### 패턴

```
시스템은 [기능]할 수 있다
```

### 예시

```markdown
## OPTIONAL (선택사항)

- 시스템은 다크 모드를 지원할 수 있다
- 시스템은 여러 언어(i18n)를 지원할 수 있다
- 시스템은 오프라인 모드를 지원할 수 있다
- 시스템은 사용자 맞춤 테마를 지원할 수 있다
- 시스템은 로그인 실패 시 재시도 제한을 할 수 있다
- 시스템은 생체 인식(지문, 안면인식)으로 로그인할 수 있다
```

### 적용 사례

**모바일 앱**:
```markdown
- 시스템은 이전 검색 기록을 저장할 수 있다
- 시스템은 즐겨찾기 기능을 제공할 수 있다
- 시스템은 알림을 설정할 수 있다
- 시스템은 계정 동기화를 지원할 수 있다
```

**문서 편집기**:
```markdown
- 시스템은 실시간 협업을 지원할 수 있다
- 시스템은 버전 히스토리를 유지할 수 있다
- 시스템은 코멘트 기능을 제공할 수 있다
- 시스템은 음성 입력을 지원할 수 있다
```

### 특징

- ✅ "할 수 있다" (의무 아님)
- ✅ MVP 이후 구현 가능
- ✅ 우선순위 낮음
- ✅ 비용 절감 가능

---

## 5️⃣ UNWANTED (제약사항)

### 정의

시스템이 **절대로** 하면 안 되는 동작이나 조건입니다. 보안, 성능, 규정상 금지사항입니다.

### 패턴

```
시스템은 [금지 동작]하면 안 된다
```

### 예시

```markdown
## UNWANTED (제약사항)

### 보안 제약
- 시스템은 비밀번호를 평문으로 저장하면 안 된다
- 시스템은 API 키를 코드에 하드코딩하면 안 된다
- 시스템은 사용자 비밀번호를 로깅하면 안 된다
- 시스템은 HTTPS 없이 민감한 데이터를 전송하면 안 된다

### 성능 제약
- 시스템은 데이터베이스 쿼리를 N+1 방식으로 실행하면 안 된다
- 시스템은 대용량 파일을 메모리에 로드하면 안 된다
- 시스템은 동기 작업으로 10초 이상 대기하면 안 된다

### 사용성 제약
- 시스템은 경고 없이 사용자 데이터를 삭제하면 안 된다
- 시스템은 브라우저의 뒤로가기 동작을 방해하면 안 된다
- 시스템은 자동 새로고침으로 사용자 입력을 잃으면 안 된다

### 규정 제약
- 시스템은 개인정보 보호법(GDPR) 규정을 위반하면 안 된다
- 시스템은 미성년자 데이터를 부모 동의 없이 수집하면 안 된다
```

### 적용 사례

**의료 시스템**:
```markdown
- 시스템은 환자 의료 기록을 무단으로 공개하면 안 된다
- 시스템은 처방약 정보를 부정확하게 표시하면 안 된다
- 시스템은 처방전 없이 약을 판매할 수 있게 하면 안 된다
```

**금융 시스템**:
```markdown
- 시스템은 거래 기록 없이 송금을 처리하면 안 된다
- 시스템은 중복 결제를 승인하면 안 된다
- 시스템은 고객 잔액을 초과하여 출금을 승인하면 안 된다
```

### 특징

- ✅ 명시적 금지 (하면 안 됨)
- ✅ 높은 우선순위
- ✅ 테스트 필수 (음수 테스트)
- ✅ 법적/보안상 중요

---

## EARS 패턴 선택 가이드

어떤 패턴을 사용해야 할까요?

### 의사결정 트리

```
요구사항을 생각했을 때

   ↓

특정 이벤트/액션이 있나?
├─ YES → EVENT-DRIVEN 사용
│  "WHEN 사용자가 [액션]하면..."
│
└─ NO → 다음 질문

   ↓

특정 상태나 조건이 있나?
├─ YES → STATE-DRIVEN 사용
│  "WHILE [상태]이면..."
│
└─ NO → 다음 질문

   ↓

항상 지켜야 하나? (조건 없음)
├─ YES → UBIQUITOUS 사용
│  "시스템은 [동작]해야 한다"
│
└─ NO → 다음 질문

   ↓

금지되어야 하나?
├─ YES → UNWANTED 사용
│  "시스템은 [동작]하면 안 된다"
│
└─ NO → OPTIONAL 사용
   "시스템은 [동작]할 수 있다"
```

---

## EARS 작성 팁

### ✅ Good Practice

**명확하고 검증 가능:**
```markdown
### EVENT-DRIVEN
- WHEN 사용자가 비밀번호 초기화를 요청하면
  - 시스템은 이메일 유효성을 확인해야 한다
  - 시스템은 초기화 토큰을 생성해야 한다
  - 시스템은 1시간 내에 유효한 초기화 링크를 이메일로 발송해야 한다
```

### ❌ Bad Practice

**모호하고 검증 불가능:**
```markdown
### EVENT-DRIVEN
- WHEN 사용자가 비밀번호 초기화를 요청하면
  - 시스템은 이메일을 보내야 한다
  - 빨리 처리해야 한다
  - 안전하게 처리해야 한다
```

### 작성 체크리스트

```markdown
□ 각 요구사항이 테스트 가능한가?
□ 모호한 단어가 없는가? (예: "빨리", "쉽게", "적절하게")
□ 측정 가능한가? (시간, 개수, 용량 등)
□ 5가지 패턴을 모두 사용했는가?
□ 우선순위가 명확한가?
□ 의존성이 명시되어 있는가?
```

---

## EARS와 테스트의 관계

EARS로 작성한 요구사항은 **자동으로 테스트 케이스**가 됩니다:

### EVENT-DRIVEN → 테스트 케이스

```markdown
# SPEC
- WHEN 사용자가 로그인하면
  - 시스템은 비밀번호를 검증해야 한다
  - 시스템은 토큰을 발급해야 한다

# 테스트
- test_login_with_valid_credentials()
- test_login_with_invalid_password()
- test_token_is_issued()
```

### STATE-DRIVEN → 테스트 케이스

```markdown
# SPEC
- WHILE 사용자가 로그인 상태이면
  - 시스템은 보호된 리소스에 접근을 허락해야 한다
- WHEN 토큰이 만료되면
  - 시스템은 재로그인을 요청해야 한다

# 테스트
- test_access_protected_resource_while_logged_in()
- test_deny_access_after_token_expiration()
```

---

## 실제 SPEC 예제

### 인증 시스템

```markdown
# SPEC-AUTH-001: 사용자 인증

## 요구사항

### UBIQUITOUS
- 시스템은 모든 비밀번호를 bcrypt로 해싱하여 저장해야 한다
- 시스템은 모든 로그인 시도를 기록해야 한다

### EVENT-DRIVEN
- WHEN 사용자가 로그인 폼을 제출하면
  - 시스템은 이메일 형식을 검증해야 한다
  - 시스템은 비밀번호와 저장된 해시를 비교해야 한다
  - 시스템은 일치할 경우 JWT 토큰을 발급해야 한다 (24시간 유효)

- WHEN 로그인에 실패하면
  - 시스템은 "잘못된 이메일 또는 비밀번호" 메시지를 표시해야 한다
  - 시스템은 5분 내 3회 이상 실패 시 계정을 임시 잠금해야 한다

### STATE-DRIVEN
- WHILE 사용자가 로그인 상태이면
  - 시스템은 매 요청 시 토큰을 검증해야 한다
  - 시스템은 보호된 API에 접근을 허락해야 한다

### OPTIONAL
- 시스템은 생체 인식 로그인을 지원할 수 있다
- 시스템은 소셜 로그인(Google, GitHub)을 지원할 수 있다

### UNWANTED
- 시스템은 비밀번호를 평문으로 저장하면 안 된다
- 시스템은 토큰을 클라이언트에 반복 전송하면 안 된다
- 시스템은 사용자 비밀번호를 로그에 기록하면 안 된다
```

---

## 다음 단계

EARS 작성을 마친 후:

1. **[SPEC-First TDD](/ko/concepts/spec-first-tdd)** - EARS 요구사항을 코드로 구현
2. **[TAG 시스템](/ko/concepts/tag-system)** - 요구사항과 코드 연결
3. **[/alfred:1-plan 시작](/ko/cli/alfred-1-plan)** - 첫 번째 SPEC 작성

---

## 참고 자료

- **EARS 원문**: Alistair Mavin의 논문
- **MoAI-ADK SPEC**: [예제 SPEC](https://github.com/moai-adk/moai-adk/tree/main/.moai/specs)
- **요구사항 검증**: TRUST 5 원칙의 "Unified" 부분
